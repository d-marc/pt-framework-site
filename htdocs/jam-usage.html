<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Basic Jam Usage</title>
  <meta content="Pt Reference Manual" name="description">
  <meta content="The Pt Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body style="margin:0px;">
<div id="container">
<div id="top"> <!-- do not remove this div, it is closed by doxygen! -->
<div id="header">
    <table id="logo">
        <tr>
            <td>
                <a href="../index.html"><img src="platinum-logo.gif" border="0"/></a>
            </td>
            <td>
                <h3>The Power in your Hands</h3>
            </td>
        </tr>
    </table>
    <div class="search">
        <form action="http://search.freefind.com/find.html" method="get" accept-charset="utf-8" target="_self">
          <p style="margin: 0; padding-top:2px; padding-bottom:2px;"><b>Search Site:</b></p>
          <p style="margin: 0; padding:0;">
            <input type="hidden" name="si" value="43943317">
            <input type="hidden" name="pid" value="r">
            <input type="hidden" name="n" value="0">
            <input type="hidden" name="_charset_" value="">
            <input type="hidden" name="bcd" value="&#247;">
            <input style="background-color: #FFFFFF;
                          border: 1px solid #ffffff;
                          font-size: 12px;
                          width: 160px"
                   type="text" name="query" value="Search...">
          </p>
        </form>
    </div>
	<div class="header-menu">
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../index.html">About</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../features-modules.html">Features</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../docs.html">Documentation</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../downloads.html">Download</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../community.html">Community</a> </div>
	</div>
  </div>
<div class="header-submenu" style="padding-left: 146px;">  
    <div class="header-submenu-term"><img src="sub_left.png" width="4" height="20" /></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="../docs.html">Main</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="classes.html">Classes</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="namespaces.html">Namespaces</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="modules.html">Modules</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-term"><img src="sub_right.png" width="4" height="20" /></div>
</div>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Basic Jam Usage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> 

<A NAME="jam_usage">
<DT><P><H1>Usage</H1><DD>
</A>

<PRE>
jam [ -a ] [ -g ] [ -n ] [ -q ] [ -v ]
    [ -d <I>debug</I> ] 
    [ -f <I>jambase</I> ] 
    [ -j <I>jobs</I> ] 
    [ -o <I>actionsfile</I> ] 
    [ -s <I>var</I>=<I>value</I> ] 
    [ -t <I>target</I> ] 
    [ <I>target</I> ... ]
</PRE>

<A NAME="jam_description">
<DT> <P> <H1> Description </H1> <DD>
</A>
    <P>

    <B>Jam</B> is a program construction tool, like <B>make</B>(1).

<P>
    <B>jam,</B> the Jam executable program, recursively builds targets
    from source files using dependency and build specifications defined
    in Jam build scripts, written in <B>jam</B>'s own interpreted
    language. <B>jam</B> parses the build scripts to identify targets and
    sources, examines the filesystem to determine which targets need updating,
    and issues OS commands to update targets. The build scripts consist of
    the Jambase which is distributed with jam and provides a boilerplate 
    dependency information and updating actions for common use. It relies 
    on the user-provided files named "Jamconfigure" and "Jamfile", to define
    the build configuration and to enumerate actual targets and sources.
    The build process is arranged in a several steps, normally consisting
    of a build configuration step, followed by a build step and finally a
    deployment or installation step.
<P>

    The Jambase is described in the <a href="jam-jambase.html">Jambase
    Reference</a> and the document <a href="jam-jamfile.html">Using the 
    Jambase</A>.
<P>

<A NAME="jam_options">
<DT> <P> <H1> Command Line Options </H1> <DD>
</A>

    <P>

    If <I>target</I> is provided on the command line, <B>jam</B>
    builds <I>target;</I> otherwise <B>jam</B> builds the target
    'all'.

    <P>

    <B>Jam</b> may be invoked with the following options:

    <P> <TABLE WIDTH=85% ALIGN=CENTER BORDER=1 CELLPADDING=2>

        <TR><TD VALIGN=TOP WIDTH=20%><CODE> -a </CODE>
        <TD> Build all targets anyway, even if they are up-to-date.

        <TR><TD VALIGN=TOP><CODE> -d <I>n</I>  </CODE>
        <TD> Enable cummulative debugging levels from 1 to <I>n</I>.  
        Interesting values are:

        <DL COMPACT>
        <DT> 1 <DD> Show actions and summary info (the default)
        <DT> 2 <DD> Show "quiet" actions and display all action text, as they are executed
        <DT> 3 <DD> Show dependency analysis, and target/source timestamps/paths
        <DT> 4 <DD> Show arguments and timming of shell invocations
        <DT> 5 <DD> Show rule invocations and variable expansions 
        <DT> 6 <DD> Show directory/header file/archive scans, and attempts at binding to targets 
        <DT> 7 <DD> Show variable settings 
        <DT> 8 <DD> Show variable fetches, variable expansions, and evaluation of '"if"' expressions 
        <DT> 9 <DD> Show variable manipulation, scanner tokens, and memory usage
        <DT> 10 <DD> Show profile information for rules, both timing and memory
        <DT> 11 <DD> Show parsing progress of Jamfiles
        <DT> 12 <DD> Show graph of target dependencies
        <DT> 13 <DD> Show change target status (fate)
        </DL>

        <TR><TD VALIGN=TOP><CODE> -d +<I>n</I> </CODE>
        <TD> Enable debugging level <I>n</I>.

        <TR><TD VALIGN=TOP><CODE> -d 0 </CODE>
        <TD> Turn off all debugging levels.  Only errors are emitted.

        <TR><TD VALIGN=TOP><CODE> -f <I>jambase</I></CODE>
        <TD>Read <I>jambase</I> instead of using the built-in Jambase.
        Multiple -f flags are permitted.

        <TR><TD VALIGN=TOP><CODE> -g </CODE>
        <TD> Build targets with the newest sources first, rather than
        in the order of appearance in the Jambase/Jamfiles.

        <TR><TD VALIGN=TOP><CODE> -j <I>n</I></CODE>
        <TD> Run up to <I>n</I> shell commands concurrently (UNIX 
        and NT only).  The default is 1.

        <TR><TD VALIGN=TOP><CODE> -n</CODE>
        <TD> Don't actually execute the updating actions, but do
        everything else.  This changes the debug level to -dax.

        <TR><TD VALIGN=TOP><CODE> -o <I>file</I></CODE>
        <TD> Write the updating actions to the specified file instead
        of running them (or outputting them, as on the Mac).

        <TR><TD VALIGN=TOP><CODE> -q </CODE>
        <TD> Quit quickly (as if an interrupt was received)
        as soon as any target build fails.

        <TR><TD VALIGN=TOP><CODE> -s <I>var</I>=<I>value</I></CODE>
        <TD> Set the variable <I>var</I> to <I>value</I>, overriding
        both internal variables and variables imported from the
        environment.

        <TR><TD VALIGN=TOP><CODE> -t <I>target</I></CODE>
        <TD> Rebuild <I>target</I> and everything that depends on it, 
         even if it is up-to-date.

        <TR><TD VALIGN=TOP><CODE> -v</CODE>
        <TD> Print the version of <B>jam</B> and exit.

    </TABLE>

<A NAME="jam_required_files">
<DT> <P> <H1> Required Files </H1> <DD>
</A>

<DT> <H3> The Jambase </H3> <DD>
<P>
    The Jambase defines rules and variables which support standard software
    build operations, like compiling, linking, etc. When <B>jam</B> is
    invoked, a file named Jambase will be looked for in the project root 
    directory, that is the entry point to the Jambase. The actual Jambase 
    resides in a directory named "jam", also located in the project root 
    directory.
    
<DT> <P> <H3> Project Specific Jam Scripts </H3> <DD>
<P>
    When the Jambase is loaded, <B>jam</B> reads up to three other user-defined
    files from the project root, the Jamconfigure script, the Jamfile and the 
    Jamrules. All three are written in the jam script language. The file 
    Jamconfigure is mandatory and describes the build configuration. The 
    Jamfile describes what to do with the source files in its directory. It 
    may also cause Jamfiles in other directories to be read. The Jamrules file
    is generated when the Jamconfigure script is executed in the configure step
    and contains a set of project-specific rule and variable definitions. The
    first Jamfile normally causes the Jamrules file to be read, when it calls
    the SubDir rule. 

<DT> <P> <H3> Jam Executable Wrappers </H3> <DD>
<P>
    Two scripts come with the jam distribution that simplify boostrapping the
    build process. One script named jam.sh runs on posix compatible build 
    hosts, the other one named jam.bat runs on windows based build hosts.
    These scripts bootstrap and run the jam executable, so that jam executables
    do not have to be included for all possible build hosts, but rather built
    on demand. A precompiled version for windows hosts is distributed with
    the scripts named jam.exe.
<P>

<A NAME="jam_build_layout">
<DT> <P> <H1> Build Process Layout </H1> <DD>
</A>
<P>
    The build process usually consists of several steps, such as:

    <UL>
        <li>Build configuration</li>
        <li>Building the targets</li>
        <li>Cleaning the build</li>
        <li>Installing targets</li>
        <li>Uninstalling targets</li>
    </UL>

    The build steps are triggered by the targets configure, clean, all,
    install and uninstall.

<DT> <P> <H3> Build Configuration </H3> <DD>
<P>
    The build must be configured before any other build steps can be performed.
    Build configuration is started when jam is executed for the target named
    "configure" and a log is written to a file named Jamrules.log. The result 
    of the configuration is the Jamrules file, which in turn is loaded at the
    begin of the build step. Before the user-defined tests are executed, the 
    built-in tests are always run to detect some basic capabilities of the
    build host platform for example how to delete files or create directories.
    The Jambase will then read in a file named Jamconfigure, which describes
    the project-specific configuration i.e. wich tests are run to determine 
    if all required dependencies, such as system headers and libraries are 
    present. 

<DT> <P> <H3> Building Targets </H3> <DD>
<P>
    After sucessful build configuration, the actual build can be started. For
    this, the Jamfile is read, which describes which targets are built from the
    source files etc. The Jamrules file is read by the first Jamfile when the 
    SubDir rue is called for the first time, which is usually as the first
    statement in a Jamfile. The build step is initiated when jam is executed
    for a build target (no target implies the target "all", which updates all
    build targets).

<DT> <P> <H3> Clean Up </H3> <DD>
<P>
    The build can be cleaned up, i.e. all built targets can be removed by 
    the clean step. Running jam for the "clean" target will work without
    error even if the build has failed or not all build targets are present
    for other reasons. The Jamfile provides information what files can be
    cleaned up.

<DT> <P> <H3> Installation and Deployment </H3> <DD>
<P>
    When targets have been built sucessfully, they can be installed. This is
    done by running jam for the target 'install'. The Jamfile also has to
    provide information what files are to be installed. The target named
    "uninstall" will remove any previously installed targets.
<P>

<A NAME="jam_execution">
<DT> <P> <H1> Program Execution </H1> <DD>
</A>
    <P>

    The <b>Jam</b> program has four phases of operation: start-up, parsing, 
    binding, and updating. These phases are performed whenever the jam 
    program is executed to perform a build step. Do not confuse the four 
    phases of operation with the steps of the build process.

<DT> <P> <H3> Start-up </H3> <DD>

    <P>

    Upon start-up, <b>jam</b> imports environment variable settings
    into <b>jam</b> variables.  Environment variables are split at
    blanks with each word becoming an element in the variable's list
    of values.  Environment variables whose names end in PATH are
    split at &#36;(SPLITPATH) characters (e.g., ":" for Unix).

    <P>

    To set a variable's value on the command line, overriding the
    variable's environment value, use the -s option.  To see variable
    assignments made during <b>jam</b>'s execution, use the -d+7
    option.

    <P>

    All command line options are also passed to the jam build scripts
    in a global variable named ARGS.

<DT> <P> <H3> Parsing </H3> <DD>

    <P>

    In the parsing phase, <b>jam</b> reads and executes the Jambase
    file, by default the built-in one. It is written in the <b>jam</b>
    language. See <a href="jam-language.html"> Language</a> below. The
    Jambase reads (via the "include" rule) the a user-provided files 
    called "Jamconfigure" and "Jamfile".

    <P>

    Collectively, the purpose of the Jambase, Jamconfigure and the 
    Jamfile is to name built targets and source files, construct the 
    dependency graph among them, and associate build actions with targets.
    The Jambase defines boilerplate rules and variable assignments,
    and the Jamconfigure and Jamfile uses these to specify the actual 
    relationship among the target and source files.  See the <a
    href="jam-jambase.html">Jambase Reference</a> and the document <a
    href="jam-jamfile.html">Using the Jambase</A> for information.

<A NAME="binding">
<DT> <P> <H3> Binding </H3> 
</A> <DD>

    <P> <H5> Binding </H5>

    After parsing, <B>jam</B> recursively descends the dependency
    graph and binds every file target with a location in the
    filesystem. The binding phase is not important for the configure
    step, where no dependency graph is set up.

    <P> <H5> Targets </H5>

    Any string value in <b>jam</b> can represent a target, and it
    does so if the DEPENDS or INCLUDES rules make it part of the
    dependency graph.  Build targets are files to be updated.  Source
    targets are the files used in updating build targets.  Build
    targets and source targets are collectively referred to as file
    targets, and frequently build targets are source targets for
    other build targets.  Pseudotargets are symbols which represent
    dependencies on other targets, but which are not themselves
    associated with any real file.

    <P>

    A file target's identifier is generally the file's name, which can
    be absolutely rooted, relative to the directory of <b>jam</b>'s
    invocation, or simply local (no directory).  Most often it is the
    last case, and the actual file path is bound using the &#36;(SEARCH)
    and &#36;(LOCATE) special variables.  See <A HREF="#search"> SEARCH
    and LOCATE Variables</A> below.  A local filename is optionally
    qualified with "grist," a string value used to assure uniqueness.
    A file target with an identifier of the form <I>file(member)</I>
    is a library member (usually an ar(1) archive on UNIX).

    <P>

    The use of &#36;(SEARCH) and &#36;(LOCATE) allows <b>jam</b> to separate
    the the location of files from their names, so that Jamfiles can
    refer to files locally (i.e. relative to the Jamfile's directory),
    yet still be usable when <b>jam</b> is invoked from a distant
    directory.  The use of grist allows files with the same name
    to be identified uniquely, so that <b>jam</b> can read a whole
    directory tree of Jamfiles and not mix up same-named targets.

    <P> <H5> Update Determination </H5>

    After binding each target, <B>jam</B> determines whether the
    target needs updating, and if so marks the target for the updating
    phase.  A target is normally so marked if it is missing, it is
    older than any of its sources, or any of its sources are marked
    for updating.  This behavior can be modified by the application
    of special built-in rules.  See <A HREF="#bindingmods">Modifying
    Binding</A> below.

    <P> <H5> Header File Scanning </H5>

    During the binding phase, <b>jam</b> also performs header file
    scanning, where it looks inside source files for the implicit
    dependencies on other files caused by C's #include syntax.  This
    is controlled by the special variables &#36;(HDRSCAN) and &#36;(HDRRULE).
    The result of the scan is formed into a rule invocation, with
    the scanned file as the target and the found included file names
    as the sources.  Note that this is the only case where rules
    are invoked outside the parsing phase.  See <A
    HREF="#hdrscan">HDRSCAN and HDRRULE Variables</A> below.

<DT> <P> <H3> Updating </H3> <DD>

    <P>

    After binding, <B>jam</B> again recursively descends the dependency
    graph,  this time executing the update actions for each target
    marked for update during the binding phase.  If a  target's
    updating actions fail, then all other targets which depend on
    that target are skipped. The updating phase is not important for 
    the configure build step, where no dependency graph is set up.

    <P>

    The -j flag instructs <B>jam</B> to build more than one target
    at a time.  If there are multiple actions on a single target,
    they are run sequentially.   The -g flag reorders builds so that
    targets with newest sources are built first.  Normally, they are
    built in the order of appearance in the Jamfiles.


<A NAME="jam_build_scripts">
<DT> <P> <H1>Jam Build Scripts</H1>  <DD>
</A>

<P>
    Jam build scripts contain rule invocations, which usually look like:
<PRE>
    <I>RuleName</I> <I>targets</I> : <I>targets</I> ;
</PRE>
    The target(s) to the left of the colon usually indicate what gets built,
    and the target(s) to the right of the colon usually indicate what it is
    built from.
<P>
    Elements in jam scripts are delimited by whitespace (blanks, tabs, or newlines).
    Elements to be delimited include rule names, targets, colons, and semicolons.
    A common mistake users make is to forget the whitespace, e.g.,
<PRE>
    Main myprog: main.c util.c ; #<I>WRONG!</I>
</PRE>
    Jam doesn't distinguish between a typo and a target called "myprog:", so 
    if you get strange results, the first thing you should check for in your
    Jamfile is missing whitespace.
<P>

<DT> <P> <H3> Jamconfigure </H3> <DD>
<P>
    A Jamconfigure script can be very simple:
<PRE>
    ConfigureCc ;
    ConfigureC++ ;
</PRE>
    This specifies that the C and C++ compiler should be configured. The rules
    named ConfigureCc and ConfigureC++ do not require any arguments, therefore
    the statement consists just of the rulename followed by a semicolon. The 
    build can then be configured by executing:
<PRE>
    jam configure
</PRE>
<P>

<DT> <P> <H3> Jamfile </H3> <DD>
<P>
    A Jamfile can be as simple as this:
<PRE>
    SubDir  ;
    Main myprog : main.c util.c ;
</PRE>
    The first statement in a Jamfile is usally the first call of the SubDir
    rule. This causes the previously generated Jamrules to be read and it
    sets the directory context of all following build rules, e.g. in where
    the sources can be found.
    This Main rule specifies that there is a main.c and util.c file in the
    same directory as specified by the SubDir rule, and that those source
    files should be compiled and linked into an executable called myprog. 
    If you cd to the directory where this Jamfile lives, you can see the 
    exactly how <b>jam</b> would build myprog with:
<PRE>
    jam -n
</PRE>
    Or, you can actually build myprog with the command:
<PRE>
    jam
</PRE>

<DT> <P> <H3> Filenames, Target Identifiers, and Buildable Targets</H3> <DD>
<P>
    Consider this Jamfile:
<PRE>
    SubDir  ;
    Main myprog : main.c util.c ;                   
    LinkLibraries myprog : tree ;     
    Library tree : treemake.c treetrav.c ;    
</PRE>
<P>
    The Main rule specifies that an executable called myprog will be built.
    The compiled main.c and util.c objects will be linked to produce myprog. 
    The LinkLibraries rule specifies that tree will be linked into myprog
    as well. The Library rule specifies which source files will be compiled 
    and archived into the tree library.
<P>
    The Jamfile above refers to targets like "myprog" and "tree". However,
    depending on the platform you're building on, the actual filenames of 
    those targets could be "myprog.exe" and "tree.lib". Most Jambase rules
    supply the actual filenames of targets, so that Jamfiles themselves need
    not make any platform-specific filename references.
<P>
    The <b>jam</b> program builds up a list of unique target identifiers.
    The default identifier for a file target is its filename prefixed with
    the path specified by the SubDir rule. In the above example, the target
    identifiers are simply the filenames: myprog.exe, tree.lib, main.obj, etc.
<P>
    You can use any buildable target on the <b>jam</b> command line to build a
    subset of defined targets. In our example:
<PRE>
    jam libtree.a 
</PRE>
    on Unix builds the libtree library and all the compiled objects that go 
    in it.
<P>

<DT> <P> <H3> Pseudotargets </H3> <DD>
<P>
    While most Jambase rules refer to "targets", not all targets are buildable.
    There are two kinds of buildable targets: file targets and pseudotargets.
    File targets are objects that can be found in the filesystem. Pseudotargets
    are symbolic, and represent other targets. Examples for preudotargets are
    "configure" or "install", which start the configure step and the install
    step, respectively.
<P>
    Most Jambase rules that define file targets also define pseudotargets
    which are dependent on types of file targets. For example, Jambase defines
    a pseudotarget called "clean", which is dependent on all targets created in
    the build step. So the command:  
<PRE>
        jam clean
</PRE> 
    used with the above example would cause the program myprog, the tree
    library, and all object files to be removed and thus clean the build.
    Also, there is one pseudotarget built into <b>jam</b> itself, called
    "all". Jambase sets "all" dependent on (almost) all other targets.
<P>
    In the unfortunate case where you have a buildable target whose name
    is the same as one of the Jambase pseudotargets, you'll have problems
    with the conflicting target name. Your workaround choices are:
<P>
<ol>
    <lI>Change the name of your buildable file or directory that conflicts.
<p>
    <li>Modify your Jambase and change the name of the conflicting pseudotarget.
    (Pseudotargets are defined in Jambase using the NOTFILE rule.)
<p>
    <li>Use grist on the conflicting target name in your Jamfile. E.g., 
        instead of
    <PRE>
        File lib : libfoo.a ;
    </PRE>
    try
    <PRE>
        File &lt;dir&gt;lib : libfoo.a ;
    </PRE>
</ol>
<P>

<DT> <P> <H3> Dependencies </H3> <DD>
<P>
    Jambase rules set dependencies on targets, so that if you update a source
    file, all the file targets that depend on that source file, and only the
    ones that depend on that source file, will be updated (rebuilt) the next
    time you run <b>jam</b>. 
<P>
    Here are some of the dependencies that get set when <b>jam</b> runs on NT
    using the example Jamfile above:
<CENTER>
    <TABLE> 
        <TR><TD><B>Target</B><TD>&nbsp;&nbsp;&nbsp;<TD><B>Depends on</B></TD>
        <TR><TD>myprog.exe<TD><TD>main.obj, util.obj, libtree.lib
        <TR><TD>libtree.lib<TD><TD>treemake.obj, treetrav.obj
        <TR><TD>treetrav.obj<TD><TD>treetrav.c
    </TABLE>
</CENTER>
<P>
    Furthermore, the Main and Library rules set up recursive header scanning
    on their source targets. So after <b>jam</b> has finished parsing the
    Jamfile and setting the rule-driven dependencies, it scans the source 
    files for "#include" lines. All #include files found during this scan
    become dependencies of the compiled object. E.g., all header files used
    to compile treetrav.c would be made dependencies of treetrav.obj.
<P>
    As a result, when you run <b>jam</b>, it will rebuild targets if either
    the source files change or the header files change. You can't tell by 
    looking at a Jamfile which header files are dependencies, but you can 
    easily display those dependencies with:
<PRE>
    jam -nd+3
</PRE>

<DT> <P> <H3> Rule Ordering </H3> <DD>
<P>
    Rules that define a target, like the Main, Library and SharedLibrary rule
    must be invoked before any other rule using the same target is invoked. 
    For example, the LinkLibraries rule for the target myprog must be called
    after the Main rule defined the target myprog. However, do not expect the
    actions to be executed later in the order the rules were invoked, as the
    rules only specify dependencies and <b>jam</b> figures out the order in 
    which targets are built from their dependencies.
<P>
    Some rules, set variables which are used by subsequent rule invocations,
    and their ordering is important. For example, the SubDir* rules (discussed
    later) must be invoked in a particular order. 
<P>

<A NAME="jam_diagnostics">
<DT> <P> <H1> Diagnostics </H1>  <DD>
</A>

    <P>

       In addition to generic error messages, <B>jam</B> may emit one of
       the following:

       <P><TABLE WIDTH=75% ALIGN=CENTER><TR><TD><DL>

       <P><DT><CODE> warning: unknown rule X </CODE> <DD>

              A rule was invoked that has not been defined with
              an "actions" or "rule" statement.

       <P><DT><CODE> using N temp target(s) </CODE> <DD>

              Targets marked as being temporary (but nonetheless
              present) have been found.

       <P><DT><CODE> updating N target(s) </CODE> <DD>

              Targets are out-of-date and will be updated.

       <P><DT><CODE> can't find N target(s) </CODE> <DD>

              Source files can't be found and there are no
              actions to create them.

       <P><DT><CODE> can't make N target(s) </CODE> <DD>

              Due to sources not being found, other targets cannot be made.

       <P><DT><CODE> warning: X depends on itself </CODE> <DD>

              A target depends on itself either directly or
              through its sources.

       <P><DT><CODE> don't know how to make X </CODE> <DD>

              A target is not present and no actions have been
              defined to create it.

       <P><DT><CODE> X skipped for lack of Y </CODE> <DD>

              A source failed to build, and thus a target cannot
              be built.

       <P><DT><CODE> warning: using independent target X </CODE> <DD>

              A target that is not a dependency of any other
              target is being referenced with &#36;(&lt;) or &#36;(&gt;).

       <P><DT><CODE> X removed </CODE> <DD>

              <b>Jam</b>  removed a  partially built target after being
              interrupted.

    </DL></TABLE>

<A NAME="jam_bugs">
<DT> <P> <H1> Bugs, Limitations </H1> <DD>
</A>

    <P>

    The -j flag can cause <B>jam</B> to get confused when single
    actions update more than one target at a time. <B>jam</B> may
    proceed as if the targets were built even though they are still
    under construction.

    <P>

    For parallel building to be successful, the dependencies among
    files must be properly spelled out, as targets tend to get built
    in a quickest-first ordering.  Also, beware of un-parallelizable
    commands that drop fixed-named files into the current directory,
    like <b>yacc</b>(1) does.

    <P>

    With the -j flag, errors from failed commands can get staggeringly
    mixed up.  

    <P>

    A poorly set &#36;(JAMSHELL) is likely to result in silent failure.

 </div></div><!-- contents -->

<div class="clear">&nbsp;</div>
<div id="footer">
	<div style="float:left;">Copyright &copy; 2003-2014 The Pt Development Team</div>
</div>
</div>
</body>
</html>
