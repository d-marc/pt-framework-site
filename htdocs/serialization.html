<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Serialization</title>
  <meta content="Pt Reference Manual" name="description">
  <meta content="The Pt Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body style="margin:0px;">
<div id="container">
<div id="top"> <!-- do not remove this div, it is closed by doxygen! -->
<div id="header">
    <table id="logo">
        <tr>
            <td>
                <a href="../index.html"><img src="platinum-logo.gif" border="0"/></a>
            </td>
            <td>
                <h3>The Power in your Hands</h3>
            </td>
        </tr>
    </table>
    <div class="search">
        <form action="http://search.freefind.com/find.html" method="get" accept-charset="utf-8" target="_self">
          <p style="margin: 0; padding-top:2px; padding-bottom:2px;"><b>Search Site:</b></p>
          <p style="margin: 0; padding:0;">
            <input type="hidden" name="si" value="43943317">
            <input type="hidden" name="pid" value="r">
            <input type="hidden" name="n" value="0">
            <input type="hidden" name="_charset_" value="">
            <input type="hidden" name="bcd" value="&#247;">
            <input style="background-color: #FFFFFF;
                          border: 1px solid #ffffff;
                          font-size: 12px;
                          width: 160px"
                   type="text" name="query" value="Search...">
          </p>
        </form>
    </div>
	<div class="header-menu">
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../index.html">About</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../features-modules.html">Features</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../docs.html">Documentation</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../downloads.html">Download</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../community.html">Community</a> </div>
	</div>
  </div>
<div class="header-submenu" style="padding-left: 146px;">  
    <div class="header-submenu-term"><img src="sub_left.png" width="4" height="20" /></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="../docs.html">Main</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="classes.html">Classes</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="namespaces.html">Namespaces</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="modules.html">Modules</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-term"><img src="sub_right.png" width="4" height="20" /></div>
</div>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Serialization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Data structures and types can be serialized to text or binary formats using Pt's serialization. This is used within the framework to load and store data or to implement remote procedure calls. It is extensible to work with all kinds of types, including STL containers, PODs (plain old data types), builtin language types or custom data types. The framework separates the process of composing and decomposing types from the formatting stage, resulting in a two-phase serialization process. This also allows to resolve and fixup shared pointers or references.</p>
<p>A type is serializable, if two operators are implemented to compose and decompose it to a SerializationInfo. The SerializationContext provides improved memory management, a mechanism to generate IDs for shared pointers and a way to further customize or override serialization for a type. Alternatively, performance can be increased by implementing a Composer or Decomposer for the type, however it is more complicated to do so.</p>
<p>Various formats are supported by implementing Formatters. Other modules of the framework also implement Formatters, for example to support serialization to XML. The Serializer and Deserializer combine a Formatter and a SerializationContext, manage composition and decomposition and thus form the high-level interface for the serialization of a set of types.</p>
<h1><a class="anchor" id="serialization_ValueTypes"></a>
Serialization of Value Types</h1>
<p>The Pt framework already provides serialization support for the C++ builtin types and the types provided by the C++ standard library, like std::string or std::vector. To make custom types serializable, the serialization operators have to be implemented. The next example shows a simple data type and the declarations of the serialization operators:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Address</div>
<div class="line">{</div>
<div class="line">    Address()</div>
<div class="line">    : code(0)</div>
<div class="line">    {}</div>
<div class="line">    </div>
<div class="line">    std::string country;</div>
<div class="line">    std::string city;</div>
<div class="line">    std::string street;</div>
<div class="line">    <span class="keywordtype">unsigned</span> code;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classPt_1_1Date.html#a808244de45ec52b6fa77e3d8a17854b5">operator &gt;&gt;=</a>(<span class="keyword">const</span> <a class="code" href="classPt_1_1SerializationInfo.html">Pt::SerializationInfo</a>&amp; si, Address&amp; address);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classPt_1_1Date.html#abb486a3a4ba29e5e1425f37dad28ff79">operator &lt;&lt;=</a>(<a class="code" href="classPt_1_1SerializationInfo.html">Pt::SerializationInfo</a>&amp; si, <span class="keyword">const</span> Address&amp; address);</div>
</div><!-- fragment --><p>Similar to the insertion and extraction operators for standard C++ iostreams, one operator has to be overloaded to serialize a type and another one to deserialize it. The types of operators (&lt;&lt;= and &gt;&gt;=) indicate that this is an assignment operation. Each type has to be composed from or decomposed to <a class="el" href="classPt_1_1SerializationInfo.html" title="Represents arbitrary types during serialization. ">Pt::SerializationInfo</a> objects, which form a tree representing the object graph. It contains all meta information so composition and decomposition can be separated from formatting and parsing. Building up the tree is highly optimized and, for example, requires only very few allocations.The next example shows the definition of the serialization operator:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classPt_1_1Date.html#abb486a3a4ba29e5e1425f37dad28ff79">operator&lt;&lt;=</a>(<a class="code" href="classPt_1_1SerializationInfo.html">Pt::SerializationInfo</a>&amp; si, <span class="keyword">const</span> Address&amp; address)</div>
<div class="line">{</div>
<div class="line">  si.<a class="code" href="classPt_1_1SerializationInfo.html#ae82877730fc266e5693db05e4643e978">addMember</a>(<span class="stringliteral">&quot;country&quot;</span>) &lt;&lt;= address.country;</div>
<div class="line">  si.<a class="code" href="classPt_1_1SerializationInfo.html#ae82877730fc266e5693db05e4643e978">addMember</a>(<span class="stringliteral">&quot;city&quot;</span>)    &lt;&lt;= address.city;</div>
<div class="line">  si.<a class="code" href="classPt_1_1SerializationInfo.html#ae82877730fc266e5693db05e4643e978">addMember</a>(<span class="stringliteral">&quot;street&quot;</span>)  &lt;&lt;= address.street;</div>
<div class="line">  si.<a class="code" href="classPt_1_1SerializationInfo.html#ae82877730fc266e5693db05e4643e978">addMember</a>(<span class="stringliteral">&quot;code&quot;</span>).<a class="code" href="classPt_1_1SerializationInfo.html#aad8ed82abfa87fd7cf07acaad78f7a64">setUInt32</a>(address.code);</div>
<div class="line">  si.<a class="code" href="classPt_1_1SerializationInfo.html#a3d659d211bc3061ce95fbcacf5fc5b7b">setTypeName</a>(<span class="stringliteral">&quot;Address&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The SerializationInfo passed by reference to the operator is meant to represent an Address object in the object graph. SerializationInfo child nodes are added for each member variable using <a class="el" href="classPt_1_1SerializationInfo.html#ae82877730fc266e5693db05e4643e978">addMember()</a>, which also assigns the name. Member types can be serialized to the returned SerializationInfo using their specific overload of the operator. For builtin integer types it is recommended to use a setter (here <a class="el" href="classPt_1_1SerializationInfo.html#aad8ed82abfa87fd7cf07acaad78f7a64">setUInt32()</a>) instead of the serialization operator, to be specific on the type. Integer types could potentially be serialized differently depending on the platform. For example, a <b>long</b> could be serialized as a 32-bit or a 64-bit integer type. Finally, the type name is set for the parent node, representing the Address object.</p>
<p>The deserialization operator performs the same process, just in reverse. The SerializationInfo object passed to it contains the meta information for all members. SerializationInfo child nodes can be obtained by name using <a class="el" href="classPt_1_1SerializationInfo.html#ab448c51fea1274d81efd7a74b26f5e47">getMember()</a> and members can be deserialized with their overloads of the deserialization operators. The following example illustrates this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classPt_1_1Date.html#a808244de45ec52b6fa77e3d8a17854b5">operator&gt;&gt;=</a>(<span class="keyword">const</span> <a class="code" href="classPt_1_1SerializationInfo.html">Pt::SerializationInfo</a>&amp; si, Address&amp; address)</div>
<div class="line">{</div>
<div class="line">  si.<a class="code" href="classPt_1_1SerializationInfo.html#ab448c51fea1274d81efd7a74b26f5e47">getMember</a>(<span class="stringliteral">&quot;country&quot;</span>) &gt;&gt;= address.country;</div>
<div class="line">  si.<a class="code" href="classPt_1_1SerializationInfo.html#ab448c51fea1274d81efd7a74b26f5e47">getMember</a>(<span class="stringliteral">&quot;city&quot;</span>)    &gt;&gt;= address.city;</div>
<div class="line">  si.<a class="code" href="classPt_1_1SerializationInfo.html#ab448c51fea1274d81efd7a74b26f5e47">getMember</a>(<span class="stringliteral">&quot;street&quot;</span>)  &gt;&gt;= address.street;</div>
<div class="line">  si.<a class="code" href="classPt_1_1SerializationInfo.html#ab448c51fea1274d81efd7a74b26f5e47">getMember</a>(<span class="stringliteral">&quot;code&quot;</span>)    &gt;&gt;= address.code;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="serialization_Pointers"></a>
Serialization of Pointers</h1>
<p>The serialization of pointers is identical to the serialization of values if the object pointed to is owned by the pointer. The pointer can simply be dereferenced and the object it points to passed to the serialization operator. However, there are rare cases, when pointers reference other objects in the object set to be serialized. These weak pointers can also be serialized using the serialization operators provided by the framework:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Pt {</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> operator&lt;&lt;=(SerializationInfo&amp; si, <span class="keyword">const</span> T* ptr);</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> operator &gt;&gt;=(<span class="keyword">const</span> SerializationInfo&amp; si, T*&amp; ptr);</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><p>Any pointer which is serialized or deserialized will be treated as a weak pointer. Depending on the format this will format or parse a reference id pointing to another object in the object stream. It does not matter in which order weak pointers and the objects pointed to are serialized, it works for both forward and backward references.</p>
<h1><a class="anchor" id="serialization_Containers"></a>
Serialization of Containers</h1>
<p>The framework already implements operators to serialize the containers of the standard C++ library. Container types from other libraries can be serialized in a similar fashion. The next example shows the serialization operator for std::vector:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> operator &lt;&lt;=(SerializationInfo&amp; si, const std::vector&lt;T, A&gt;&amp; vec)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typename</span> std::vector&lt;T, A&gt;::const_iterator it;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(it = vec.begin(); it != vec.end(); ++it)</div>
<div class="line">    {</div>
<div class="line">        si.<a class="code" href="classPt_1_1SerializationInfo.html#aff082f70de904c84bf4c9b1da803bdbd">addElement</a>() &lt;&lt; Pt::save() &lt;&lt;= *it;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    si.<a class="code" href="classPt_1_1SerializationInfo.html#a3d659d211bc3061ce95fbcacf5fc5b7b">setTypeName</a>(<span class="stringliteral">&quot;std::vector&quot;</span>);</div>
<div class="line">    si.<a class="code" href="classPt_1_1SerializationInfo.html#ae85292bade5ec61bd6e8ddb85bbaad35">setSequence</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Each element of the vector is added to the parent SerializationInfo using <a class="el" href="classPt_1_1SerializationInfo.html#aff082f70de904c84bf4c9b1da803bdbd">addElement()</a>. The modifier Pt::save() marks the element as a type that is potentially referencable by a weak pointer in another object. This improves performance, because the serializer only has to consider 'reachable' objects when pointers are also serialized. At the end, a type name is set and the type of the parent SerializationInfo note is set to 'sequence'. This is neccessary to allow empty vectors. Deserialization is somewhat similar:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classPt_1_1Date.html#a808244de45ec52b6fa77e3d8a17854b5">operator &gt;&gt;=</a>(<span class="keyword">const</span> SerializationInfo&amp; si, std::vector&lt;T, A&gt;&amp; vec)</div>
<div class="line">{</div>
<div class="line">    T elem = T();</div>
<div class="line">    vec.clear();</div>
<div class="line">    vec.reserve( si.memberCount() );</div>
<div class="line"></div>
<div class="line">    SerializationInfo::ConstIterator end = si.end();</div>
<div class="line">    <span class="keywordflow">for</span>(SerializationInfo::ConstIterator it = si.begin(); it != end; ++it)</div>
<div class="line">    {</div>
<div class="line">        vec.push_back(elem);</div>
<div class="line">         it &gt;&gt; Pt::load() &gt;&gt;= vec.back();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>As an optimization, the vector reserves the memory for its element first. Then all elements in the parent SerializationInfo are deserialized into the back of the vector. The modifier Pt::load() marks the deserialized object as being referencable by a pointer in another object, similar to Pt::save().</p>
<p>Considering the implementations of the serialization operators for std::vector, one significant problem becomes apparent. It consumes a lot of memory for containers with many elements, because it requires the complete tree of SerializationInfo objects representing the container to be in memory. It can not work incrementally.</p>
<p>An alternative to implementing the serialization operators is to specialize <a class="el" href="classPt_1_1BasicComposer.html" title="Manages the composition of types during serialization. ">Pt::BasicComposer</a> and <a class="el" href="classPt_1_1BasicDecomposer.html" title="Manages the decomposition of types during serialization. ">Pt::BasicDecomposer</a>. The default implementations use the serialization operators and a tree of SerializationInfo objects, which is fine for small and medium sized objects. The parsing anfd formatting layers interact with these two classes to compose or decompose the actual types and this layer can be completely customized. The following examples show the specializations for std::vector:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Pt {</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>BasicComposer&lt; std::vector&lt;T&gt; &gt; : <span class="keyword">public</span> Composer</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <a class="code" href="classPt_1_1BasicComposer.html#af5740c51298f9c9454bb0df456e3972d">BasicComposer</a>(SerializationContext* context = 0)</div>
<div class="line">        : _type(0)</div>
<div class="line">        {</div>
<div class="line">            _elemComposer.setParent(<span class="keyword">this</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="classPt_1_1BasicComposer.html#a6aa0fe55c467a35a5ea68c5583861762">begin</a>(std::vector&lt;T&gt;&amp; type)</div>
<div class="line">        {</div>
<div class="line">            _type = &amp;type;</div>
<div class="line">            _type-&gt;clear();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPt_1_1BasicComposer.html#a202db30bcd3ad74bd11be0ef6d8b3ecc">onSetId</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keywordtype">id</span>, std::size_t len)</div>
<div class="line">        { }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <a class="code" href="classPt_1_1Composer.html">Pt::Composer</a>* <a class="code" href="classPt_1_1BasicComposer.html#aabba2a186bcdf997fb29d08ed563386a">onBeginElement</a>()</div>
<div class="line">        {</div>
<div class="line">            _type-&gt;push_back( T() );</div>
<div class="line">            _elemComposer.begin( _type-&gt;back() );</div>
<div class="line">            <span class="keywordflow">return</span> &amp;_elemComposer;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        std::vector&lt;T&gt;* _type;</div>
<div class="line">        BasicComposer&lt;T&gt; _elemComposer;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><p>The specialized BasicComposer needs to inherit <a class="el" href="classPt_1_1Composer.html" title="Composes types during serialization. ">Pt::Composer</a>, which is the interface used by the deserializer to report parse events. The virtual functions <a class="el" href="classPt_1_1Composer.html#a5af604d40db6ffd5f30c03065186b0f3">onBeginElement()</a> and <a class="el" href="classPt_1_1Composer.html#af27a188523c05ba92cdb75cf68e70c31">onSetId()</a> are overridden to build the vector from the parse events. The function onBeginElement() is called, when the begin of a vector element was parsed. It should set up and return a composer for the new element in the vector. A constructor is required that optionally takes a reference to a <a class="el" href="classPt_1_1SerializationContext.html" title="Context for the serialization of types. ">Pt::SerializationContext</a>. The context can be used in onSetId() to map a reference ID to the vector being composed, if another object has a weak reference to it (not shown here). The begin() function is also required, to set up the composer to start composing a type.</p>
<p>The specialization of a BasicDecomposer is somewhat similar. It needs to derive <a class="el" href="classPt_1_1Decomposer.html" title="Manages the decomposition of types during serialization. ">Pt::Decomposer</a>, which is the interface used by the deserializer to drive output to a formatter.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Pt {</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>BasicDecomposer&lt; std::vector&lt;T&gt; &gt; : <span class="keyword">public</span> Decomposer</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <a class="code" href="classPt_1_1BasicDecomposer.html#afa1499447806067d979c347a93627343">BasicDecomposer</a>(SerializationContext* context = 0)</div>
<div class="line">        : _type(0)</div>
<div class="line">        { </div>
<div class="line">            _elemDecomposer.setParent(<span class="keyword">this</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="classPt_1_1BasicDecomposer.html#a23234d89a029fda36b9a7c53f1f1f632">begin</a>(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; type, <span class="keyword">const</span> <span class="keywordtype">char</span>* name)</div>
<div class="line">        {</div>
<div class="line">            _type = &amp;type;</div>
<div class="line">            _name = name;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="classPt_1_1BasicDecomposer.html#a4966f2c2c5363c2b3577e42579273527">onBeginFormat</a>(Formatter&amp; formatter)</div>
<div class="line">        {</div>
<div class="line">            formatter.beginSequence(_name.c_str(), <span class="stringliteral">&quot;std::vector&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">            _it = _type-&gt;begin();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <a class="code" href="classPt_1_1Decomposer.html#aeea39bfe2d235eb687bd46b1ead77f7d">Decomposer</a>* <a class="code" href="classPt_1_1BasicDecomposer.html#a8e203ec4095e58e4c18c023bc1a064ae">onAdvanceFormat</a>(Formatter&amp; formatter)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span>( _it != _type-&gt;begin() )</div>
<div class="line">            {</div>
<div class="line">                formatter.finishElement();</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span>( _it == _type-&gt;end() )</div>
<div class="line">            {</div>
<div class="line">                formatter.finishSequence();</div>
<div class="line">                <span class="keywordflow">return</span> this-&gt;<a class="code" href="classPt_1_1Decomposer.html#ad81cde3d605f6780709ec307a655a519">parent</a>();</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            formatter.beginElement();</div>
<div class="line">            _elemDecomposer.begin(*_it, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">            _elemDecomposer.beginFormat(formatter);</div>
<div class="line">            ++_it;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> &amp;_elemDecomposer;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        std::string _name;</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;T&gt;* _type;</div>
<div class="line">        BasicDecomposer&lt;T&gt; _elemDecomposer;</div>
<div class="line">        <span class="keyword">typename</span> std::vector&lt;T&gt;::const_iterator _it;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><p>It also requires a constructor to optionally take a reference to a SerializationContext and a begin() function to set up the decomposer to start decomposing a vector by a name. The virtual function <a class="el" href="classPt_1_1Decomposer.html#a50c7a10c00d2abba617b1d2fc8937769">onBeginFormat()</a> and <a class="el" href="classPt_1_1Decomposer.html#a0533648f6d97e733fed30479cd0358b8">onAdvanceFormat()</a> are overridden to react to formatting events. The first is called when the vector should be started to be formatted. Therefore <a class="el" href="classPt_1_1Formatter.html#a40ac858247ebb3452f81940a6ccf920f">beginSequence()</a> is used to format the begin of the sequence and we keep an iterator to the begin of the vector. The function onAdvanceFormat() is called, when the next element can be formatted. To finish the current element, <a class="el" href="classPt_1_1Formatter.html#a5c06d4a635c77f67ca2378315aa2c8f8">finishElement()</a> is called, <a class="el" href="classPt_1_1Formatter.html#aff59bd3122e1d4462f749477a59b9227">beginElement()</a> is called to start the next element and <a class="el" href="classPt_1_1Formatter.html#a5a031fd700f98734bca1febefa08a1ad">finishSequence()</a> is called when the end of the vector is reached. A decomposer is returned, either for the current vector element, or the parent decomposer, if all elements were decomposed.</p>
<p>Both, the BasicComposer and BasicDecomposer may delegate to other composers and decomposers, which might or might not be specialized. In the example for std::vector, composers and decomposers for the element type are used. Note, that this works for a vector of vectors right away. It is usually a good compromise to rely on the serialization operators for small or medium sized data types, but specialize the coposer and decomposer for container types. </p>
</div></div><!-- contents -->

<div class="clear">&nbsp;</div>
<div id="footer">
	<div style="float:left;">Copyright &copy; 2003-2014 The Pt Development Team</div>
</div>
</div>
</body>
</html>
