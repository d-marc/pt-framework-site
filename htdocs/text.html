<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Text Processing</title>
  <meta content="Pt Reference Manual" name="description">
  <meta content="The Pt Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body style="margin:0px;">
<div id="container">
<div id="top"> <!-- do not remove this div, it is closed by doxygen! -->
<div id="header">
    <table id="logo">
        <tr>
            <td>
                <a href="../index.html"><img src="platinum-logo.gif" border="0"/></a>
            </td>
            <td>
                <h3>The Power in your Hands</h3>
            </td>
        </tr>
    </table>
    <div class="search">
        <form action="http://search.freefind.com/find.html" method="get" accept-charset="utf-8" target="_self">
          <p style="margin: 0; padding-top:2px; padding-bottom:2px;"><b>Search Site:</b></p>
          <p style="margin: 0; padding:0;">
            <input type="hidden" name="si" value="43943317">
            <input type="hidden" name="pid" value="r">
            <input type="hidden" name="n" value="0">
            <input type="hidden" name="_charset_" value="">
            <input type="hidden" name="bcd" value="&#247;">
            <input style="background-color: #FFFFFF;
                          border: 1px solid #ffffff;
                          font-size: 12px;
                          width: 160px"
                   type="text" name="query" value="Search...">
          </p>
        </form>
    </div>
	<div class="header-menu">
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../index.html">About</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../features-modules.html">Features</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../docs.html">Documentation</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../downloads.html">Download</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../community.html">Community</a> </div>
	</div>
  </div>
<div class="header-submenu" style="padding-left: 146px;">  
    <div class="header-submenu-term"><img src="sub_left.png" width="4" height="20" /></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="../docs.html">Main</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="classes.html">Classes</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="namespaces.html">Namespaces</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="modules.html">Modules</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-term"><img src="sub_right.png" width="4" height="20" /></div>
</div>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Text Processing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This set of classes and functions extends the string and localization support of the C++ standard library to work with unicode characters and strings. A unicode character type and string class (a specialization of std::basic_string) can be used to hold unicode text. A set of functions allows to transform and classify individual characters. Text can be converted e.g. between different encodings using i/o streams and text codecs. A regular expression class allows to search and match patterns in unicode strings. Localization facets are available for the systems which support standard C++ locales.</p>
<h1><a class="anchor" id="text_Encodings"></a>
Character Encodings</h1>
<p>One of the most common standards for character encoding is the ASCII-standard. Each character is encoded using 7 bits of a byte, so 128 different characters can be adressed. Reading and writing ASCII characters is straight forward, because each character is stored in exactly one byte. The builtin C++ type <b>char</b> can be used to represent ASCII characters. The draw-back of ASCII, of course, is the small character set of only 128 characters. There are a lot more characters than that in the languages all around the world.</p>
<p>This problem was addressed by the Unicode standard, which was created to make every known character of the world available in a single character table. Each character has a defined position in the table, a so-called code point. The unicode table contains 0x10FFFF entries at the moment, so a 32 bit type is required to represent a raw unicode character.</p>
<p>The UTF-8 encoding was introduced to store unicode characters in byte sequences, which are compatible to classic null-terminated C strings. One unicode character is encoded into a byte sequence of 1 or more bytes. Further, the characters are encoded such that a character in 7-bit-ASCII has the exact same value as in UTF-8, so any valid ASCII text is valid UTF-8 encoded text. This demonstrates the difference between encodings and character types. ASCII and UTF-8 can both be represented by sequences of the character type <b>char</b>, but their values are interpreted according to the encoding. Besides UTF-8 encoding, a many more encodings have been developed, for example Latin-1, UTF-16 or in the broadest sense Base64.</p>
<h1><a class="anchor" id="text_Characters"></a>
Characters and Strings</h1>
<p>The unicode character type <a class="el" href="classPt_1_1Char.html" title="Unicode character type. ">Pt::Char</a> can directly represent a unicode code point. It is used as the character type for <a class="el" href="classPt_1_1String.html" title="Unicode capable basic_string. ">Pt::String</a> or <a class="el" href="classPt_1_1StringStream.html" title="Unicode string stream. ">Pt::StringStream</a>. Characters can be classified or transformed using a set of functions similar to what can be found in the cctype header of the standard library:</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1Char.html">Pt::Char</a> ch = <span class="charliteral">&#39;a&#39;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// check character category</span></div>
<div class="line">assert( <a class="code" href="classPt_1_1Char.html#aedf2799de331bdecfc9f3b30218f0f19">isalpha</a>(ch) );</div>
<div class="line">assert( <a class="code" href="classPt_1_1Char.html#ab9bf6945169c1b63b26d646a0b1218b4">islower</a>(ch) );</div>
<div class="line"></div>
<div class="line"><span class="comment">// convert to upper case</span></div>
<div class="line"><a class="code" href="classPt_1_1Char.html">Pt::Char</a> ch2 = <a class="code" href="classPt_1_1Char.html#a882b1a31c1671a3febe092bb52fc7a80">toupper</a>(ch);</div>
<div class="line">assert( <a class="code" href="classPt_1_1Char.html#af65123f3eb14bc425760eb2ca615065d">isupper</a>(ch) );</div>
</div><!-- fragment --><p>This class <a class="el" href="classPt_1_1String.html" title="Unicode capable basic_string. ">Pt::String</a> is not yet another unicode string class, but it is a specialization of the std::basic_string template for the unicode character type <a class="el" href="classPt_1_1Char.html" title="Unicode character type. ">Pt::Char</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::basic_string&lt;Pt::Char&gt; String;</div>
</div><!-- fragment --><p>It offers all the functionality of the std::basic_string template. This has the advantage, that all generic algorithms that work with std::basic_string should also work with <a class="el" href="classPt_1_1String.html" title="Unicode capable basic_string. ">Pt::String</a>. Please refer to a standard c++ manual for a complete overview. Additional methods make it easier to work with other character types. For example, the relational operators are also overloaded for char and wchar_t.</p>
<p>Since a specialization of std::char_traits is also provided, the C++ iostreams can be instantiated for Pt::Char, including the string streams. Three typedefs provide shorter names for the unicode capable string streams:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::basic_istringstream&lt;Pt::Char&gt; IStringStream;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> std::basic_ostringstream&lt;Pt::Char&gt; OStringStream;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> std::basic_stringstream&lt;Pt::Char&gt; StringStream;</div>
</div><!-- fragment --><p>The insertion and extraction opertors (&lt;&lt; and &gt;&gt;) for iostreams require certain localization factes to be present in the std::locale. Pt will install specializations of std::num_put, std::num_get, std::numpunct and std::ctype for Pt::Char. This means that all other facilities that use localization facets will also work.</p>
<h1><a class="anchor" id="text_TextStreams"></a>
Text Streams and Codecs</h1>
<p>Text streams can be used to convert text between different encodings and character types. The text streams are derived from the I/O streams provided by the C++ standard library, so there is a a stream type for input, for output and for both, respectively. The basic class templates look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharT, <span class="keyword">typename</span> ByteT&gt;</div>
<div class="line"><span class="keyword">class </span>BasicTextIStream : <span class="keyword">public</span> std::basic_istream&lt;CharT&gt;...</div>
<div class="line"></div>
<div class="line">template &lt;typename CharT, typename ByteT&gt;</div>
<div class="line">class BasicTextOStream : <span class="keyword">public</span> std::basic_ostream&lt;CharT&gt;...</div>
<div class="line"></div>
<div class="line">template &lt;typename CharT, typename ByteT&gt;</div>
<div class="line">class BasicTextStream : <span class="keyword">public</span> std::basic_iostream&lt;CharT&gt;...</div>
</div><!-- fragment --><p>Text streams do not only convert between text encodings, but also between character types of different size. The first template parameter is the character type of the decoded text and the second one is the character type of the encoded text. They are also called internal and external character types and may also be of the same type. The internal character type is used as the character type of the standard C++ stream base class. Besides the three class templates, there are typedefs for the most common case in Pt, where the internal character type is <a class="el" href="classPt_1_1Char.html" title="Unicode character type. ">Pt::Char</a> and the external character type is of type <b>char:</b> </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> BasicTextIStream&lt;Char, char&gt; TextIStream;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> BasicTextOStream&lt;Char, char&gt; TextOStream;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> BasicTextStream&lt;Char, char&gt; TextStream;</div>
</div><!-- fragment --><p>A text stream always works with another stream as input or output. A text input stream works with another std::basic_istream to read the encoded input. A text output stream needs another std::basic_ostream to write the encoded output. This underlying stream uses the external character type. For example, the TextIStream, which uses char as the external character type, can operate on any std::istream.</p>
<p>A <a class="el" href="classPt_1_1TextCodec.html" title="Converts between character encodings. ">Pt::TextCodec</a> is used by text converters to encode and decode external byte sequences, hence the name codec. It implements the std::codecvt facet interface, on systems provide the std::locale facilities. Codecs are stateless, which means that one codec can be used with multiple text converters. A TextCodec is constructed with a reference counter that indicates whether the converter or locale manages the lifetime of the codec. If that value is 0, as it is the case if the TextCodec is default constructed, the text converter or locale will delete the codec.</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1TextOStream.html">Pt::TextOStream</a> tos(<span class="keyword">new</span> <a class="code" href="classPt_1_1Utf8Codec.html">Pt::Utf8Codec</a>);</div>
</div><!-- fragment --><p>Therefore, a default constructed TextCodec has to be cretaed with new, as it is the rule for all localization facets. This can be avoided by passing a value different from 0 to the codecs constructor, in which case the codec must exist at least as long as the stream that uses it:</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1Utf8Codec.html">Pt::Utf8Codec</a> codec(1);</div>
<div class="line"><a class="code" href="classPt_1_1TextOStream.html">Pt::TextOStream</a> tos(codec);</div>
</div><!-- fragment --><p>A text stream can be constructed with an underlying stream and a TextCodec, but both can also be set or reset later. If no codec is set, the stream will directly assign characters, instead of converting them. If no target stream is set, the text stream will always be EOF. The following example demonstrates how a string stream is used as the input for a text stream, which uses a <a class="el" href="classPt_1_1Utf8Codec.html" title="Convert between unicode and UTF-8. ">Pt::Utf8Codec</a> to decode UTF-8 encoded text:</p>
<div class="fragment"><div class="line">std::istringstream iss(<span class="stringliteral">&quot;UTF-8 encoded text&quot;</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1String.html">Pt::String</a> s;</div>
<div class="line"><a class="code" href="classPt_1_1TextIStream.html">Pt::TextIStream</a> tis(iss, <span class="keyword">new</span> <a class="code" href="classPt_1_1Utf8Codec.html">Pt::Utf8Codec</a>());</div>
<div class="line">std::getline(tis, s);</div>
</div><!-- fragment --><p>The std::getline function will read all input into a <a class="el" href="classPt_1_1String.html" title="Unicode capable basic_string. ">Pt::String</a>. Of course, the extraction operator can also be used, for example, to directly read numbers from the stream. The next example shows how to encode text to an UTF-8 byte sequence:</p>
<div class="fragment"><div class="line">std::ostringstream oss;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1String.html">Pt::String</a> s = L<span class="stringliteral">&quot;Hello World!&quot;</span>;</div>
<div class="line"><a class="code" href="classPt_1_1TextOStream.html">Pt::TextOStream</a> tos(oss, <span class="keyword">new</span> <a class="code" href="classPt_1_1Utf8Codec.html">Pt::Utf8Codec</a>());</div>
<div class="line">tos &lt;&lt; s;</div>
<div class="line">tos.flush();</div>
</div><!-- fragment --><p>The string stream serves as the output of the text stream, which uses a Pt::Utf8codec to encode text to UTF-8. The insertion operator can be used, for strings or to format numbers. When all data has been written to the text stream, flush needs to be called to finish off the output byte sequence. This is especially important for encodings with shift states.</p>
<h1><a class="anchor" id="text_Regex"></a>
Regular Expressions</h1>
<p>The <a class="el" href="classPt_1_1Regex.html" title="Regular Expressions for Unicode Strings. ">Pt::Regex</a> class allows to match a string pattern in unicode text. It resembles the std::basic_regex class and can be used to support systems, where std::basic_regex is not available in the standard C++ implementation. The syntax for the match pattern is similar to the extended POSIX syntax. The following table shows the special characters that can be used to write regular expressions:</p>
<table  style="width:600px; margin:20px; padding:6px; background-color: #eff0f0;">
<tr>
<td><b>.</b> </td><td>Any character  </td></tr>
<tr>
<td><b>[ ]</b> </td><td>A character in a given set  </td></tr>
<tr>
<td><b>[^ ]</b> </td><td>A character not in a given set  </td></tr>
<tr>
<td><b>^</b> </td><td>Begin of line  </td></tr>
<tr>
<td><b>$</b> </td><td>End of line  </td></tr>
<tr>
<td><b>\&lt;</b> </td><td>Begin of a word  </td></tr>
<tr>
<td><b>\&gt;</b> </td><td>End of a word  </td></tr>
<tr>
<td><b>( )</b> </td><td>A marked subexpression  </td></tr>
<tr>
<td><b>*</b> </td><td>Matches the preceding element zero or more times  </td></tr>
<tr>
<td><b>?</b> </td><td>Matches the preceding element zero or one time  </td></tr>
<tr>
<td><b>+</b> </td><td>Matches the preceding element one or more times  </td></tr>
<tr>
<td><b>|</b> </td><td>Matches either the expression before or after the operator  </td></tr>
<tr>
<td><b>\ </b> </td><td>Escapes the next character  </td></tr>
</table>
<p>The regular expression is constructed from a unicode string, either a <a class="el" href="classPt_1_1String.html" title="Unicode capable basic_string. ">Pt::String</a> or a null-terminated sequence of unicode characters of type <a class="el" href="classPt_1_1Char.html" title="Unicode character type. ">Pt::Char</a>. It can then be used to match it against unicode strings as shown in the next example:</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1String.html">Pt::String</a> expr = L<span class="stringliteral">&quot;[hc]ats&quot;</span>;</div>
<div class="line"><a class="code" href="classPt_1_1Regex.html">Pt::Regex</a> regex(expr);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1String.html">Pt::String</a> str1 = L<span class="stringliteral">&quot;I like cats!&quot;</span>;</div>
<div class="line"><a class="code" href="classPt_1_1String.html">Pt::String</a> str2 = L<span class="stringliteral">&quot;I like hats!&quot;</span>;</div>
<div class="line"><a class="code" href="classPt_1_1String.html">Pt::String</a> str3 = L<span class="stringliteral">&quot;I like bats!&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// this does match</span></div>
<div class="line"><span class="keywordtype">bool</span> matched = regex.match(str1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// this does also match</span></div>
<div class="line">matched = regex.match(str2);</div>
<div class="line"></div>
<div class="line"><span class="comment">// this does not match</span></div>
<div class="line">matched = regex.match(str3);</div>
</div><!-- fragment --><p>It is also possibe to match a regular expression against a unicode input string and find out what tokens in the string actually matched. The <a class="el" href="classPt_1_1Regex.html#a3ed6158b37b428513d916ed44cc40e94">match()</a> member function has an overload, which fills a <a class="el" href="classPt_1_1RegexSMatch.html" title="Result of a regular expression match. ">Pt::RegexSMatch</a> with the result. Note that the first result at index 0 is always the input string itself. The following example illustrates this:</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1String.html">Pt::String</a> expr = L<span class="stringliteral">&quot;([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)&quot;</span>;</div>
<div class="line"><a class="code" href="classPt_1_1Regex.html">Pt::Regex</a> regex(expr);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1String.html">Pt::String</a> str = L<span class="stringliteral">&quot;My IP address is 192.168.0.77&quot;</span>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1RegexSMatch.html">Pt::RegexSMatch</a> smatch;</div>
<div class="line"><span class="keywordtype">bool</span> matched = regex.match(str, smatch);</div>
<div class="line"><span class="keywordflow">if</span>(matched)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;IP: &quot;</span> &lt;&lt; smatch.<a class="code" href="classPt_1_1RegexSMatch.html#ab1c2a6025066d219b8575e9f0939ca4b">str</a>(1).<a class="code" href="classPt_1_1String.html#a3d69ce99863d01d3c2952df83faff429">narrow</a>() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;No IP in &quot;</span> &lt;&lt; smatch.<a class="code" href="classPt_1_1RegexSMatch.html#ab1c2a6025066d219b8575e9f0939ca4b">str</a>(0).<a class="code" href="classPt_1_1String.html#a3d69ce99863d01d3c2952df83faff429">narrow</a>() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="text_Base64"></a>
Base-64 Encoding</h1>
<p>The Base64 encoding scheme is not a character encoding in the classical sense, but works very similar to other types of encodings. The framework provides a text codec to convert to and from base64 encoded text named <a class="el" href="classPt_1_1Base64Codec.html" title="A codec for base-64 encoding. ">Pt::Base64Codec</a>. It can be used with the basic text stream templates, where the internal and external character types are both char. The following example shows how text is converted to base64:</p>
<div class="fragment"><div class="line">std::ostringstream oss;</div>
<div class="line">              </div>
<div class="line">BasicTextOStream&lt;char, char&gt; b64(oss, <span class="keyword">new</span> Base64Codec());</div>
<div class="line">b64 &lt;&lt; <span class="stringliteral">&quot;Hello World!&quot;</span>;</div>
<div class="line">b64.flush();</div>
</div><!-- fragment --><p>The string stream serves as the output for the base64 encoded text. The base64 codec is used with a basic text stream to convert the string "Hello World!". Here, it is important to terminate the output sequence by calling flush, because the base64 format requires padding at the end. Note, that inserting std::endl will also terminate the base64 sequence. </p>
</div></div><!-- contents -->

<div class="clear">&nbsp;</div>
<div id="footer">
	<div style="float:left;">Copyright &copy; 2003-2014 The Pt Development Team</div>
</div>
</div>
</body>
</html>
