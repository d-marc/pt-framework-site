<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Dynamic Libraries and Plugins</title>
  <meta content="Pt Reference Manual" name="description">
  <meta content="The Pt Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body style="margin:0px;">
<div id="container">
<div id="top"> <!-- do not remove this div, it is closed by doxygen! -->
<div id="header">
    <table id="logo">
        <tr>
            <td>
                <a href="../index.html"><img src="platinum-logo.gif" border="0"/></a>
            </td>
            <td>
                <h3>The Power in your Hands</h3>
            </td>
        </tr>
    </table>
    <div class="search">
        <form action="http://search.freefind.com/find.html" method="get" accept-charset="utf-8" target="_self">
          <p style="margin: 0; padding-top:2px; padding-bottom:2px;"><b>Search Site:</b></p>
          <p style="margin: 0; padding:0;">
            <input type="hidden" name="si" value="43943317">
            <input type="hidden" name="pid" value="r">
            <input type="hidden" name="n" value="0">
            <input type="hidden" name="_charset_" value="">
            <input type="hidden" name="bcd" value="&#247;">
            <input style="background-color: #FFFFFF;
                          border: 1px solid #ffffff;
                          font-size: 12px;
                          width: 160px"
                   type="text" name="query" value="Search...">
          </p>
        </form>
    </div>
	<div class="header-menu">
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../index.html">About</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../features-modules.html">Features</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../docs.html">Documentation</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../downloads.html">Download</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../community.html">Community</a> </div>
	</div>
  </div>
<div class="header-submenu" style="padding-left: 146px;">  
    <div class="header-submenu-term"><img src="sub_left.png" width="4" height="20" /></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="../docs.html">Main</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="classes.html">Classes</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="namespaces.html">Namespaces</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="modules.html">Modules</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-term"><img src="sub_right.png" width="4" height="20" /></div>
</div>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Dynamic Libraries and Plugins </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Dynamic libraries can be loaded at runtime and symbols can be resolved using the <a class="el" href="classPt_1_1System_1_1Library.html" title="Shared library loader. ">Pt::System::Library</a> class. Additionally, the plugin API provides a more advanced way of creating classes, that implement a common interface, from a dynamically loadable library or module. The mechanism is non-intrusive and can be used with an existing class hierachy. Plugins can be loaded and unloded by client application code. The concrete type of the created class is opaque to the application that uses the plugin, it only needs to know the interface.</p>
<h1><a class="anchor" id="plugins_Libraries"></a>
Loading Libraries</h1>
<p>The <a class="el" href="classPt_1_1System_1_1Library.html" title="Shared library loader. ">Pt::System::Library</a> class can be used to dynamically load shared libraries and resolve symbols from it. It also provides the static functions <a class="el" href="classPt_1_1System_1_1Library.html#a413a7cbc7d2d88c93d45dd6876d92e2e">prefix()</a> and <a class="el" href="classPt_1_1System_1_1Library.html#ad2be6adae4bfadedd5f9acd1ad4a5810">suffix()</a>, which allow to build library names in a portable way. The next example shows how to load a library with the basename "MyLib" at runtime and how to retrieve the address of the function "myFunction":</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> int (*MyFunc)();</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1System_1_1Path.html">Pt::System::Path</a> libPath = <span class="stringliteral">&quot;MyLib&quot;</span>;</div>
<div class="line"><a class="code" href="classPt_1_1System_1_1Library.html">Pt::System::Library</a> library(libPath);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1System_1_1Symbol.html">Pt::System::Symbol</a> symbol = library.getSymbol(<span class="stringliteral">&quot;myFunction&quot;</span>);</div>
<div class="line"></div>
<div class="line">MyFunc func = <span class="keyword">reinterpret_cast&lt;</span>MyFunc<span class="keyword">&gt;</span>(symbol.<a class="code" href="classPt_1_1System_1_1Symbol.html#a0dcf7a15571116db2b409c54e9039ff7">sym</a>());</div>
<div class="line"><span class="keywordtype">int</span> result = func();</div>
</div><!-- fragment --><p>The constructor of the Library class will try to load the library at the given path. If no library could be found, the path is extended by the platform-specific library extension first, and then also by the shared library prefix. If no library could be found at either path, an <a class="el" href="classPt_1_1AccessFailed.html">AccessFailed</a> exception is thrown. The function <a class="el" href="classPt_1_1System_1_1Library.html#a819e88347928d98fb53a2e9a8e100931">getSymbol()</a> returns a <a class="el" href="classPt_1_1System_1_1Symbol.html">Symbol</a> object when the library symbol could be resolved or a <a class="el" href="classPt_1_1System_1_1SymbolNotFound.html">SymbolNotFound</a> exception, if the symbol name could not be found. The actual address of the library symbol is returned by <a class="el" href="classPt_1_1System_1_1Symbol.html#a0dcf7a15571116db2b409c54e9039ff7">sym()</a>. Alternatively, the index operator can be used to load symbols, which will return the address of the symbol as a pointer to void or a nullptr on failure. Note, that standard C++ does not allow to cast void pointers to function pointers, but nearly all runtimes implement that as an extension.</p>
<h1><a class="anchor" id="plugins_Implementation"></a>
Writing Plugins</h1>
<p>Lets assume the classes you want to create from a plugin are derived from an interface class called Greeter. The Greeter class has one abstract function called sayHello:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Greeter</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">virtual</span> ~Greeter() {}</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> sayHello() <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Now, we want to write a plugin that implements Greeter to say "Hello World" in english. This simply means to derive from Greeter and implement the sayHello method:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>EnglishGreeter : <span class="keyword">public</span> Greeter</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">void</span> sayHello()</div>
<div class="line">        { </div>
<div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;Hello World\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">};</div>
</div><!-- fragment --><p>So far this has nothing to do with writing the plugin, it is pretty much the situation how object-oriented applications and frameworks are designed. To build the plugin, the EnglishGreeter must be build as a shared library and export the symbol "PluginList" that we will use later to resolve our plugin. PluginList must be a null-terminated array of PluginId* and be exported with C-linkage. This array will contain a number of BasicPlugin instances that serve as builder for the class we want to load from the plugin in our client application.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="classPt_1_1System_1_1BasicPlugin.html">Pt::System::BasicPlugin&lt;EnglishGreeter, Greeter&gt;</a> _enGreeter(<span class="stringliteral">&quot;en&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1System_1_1PluginId.html">Pt::System::PluginId</a>* PluginList[] = { &amp;_enGreeter, 0 };</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here we create a BasicPlugin statically in the plugin library that is able to create an EnglishGreeter which implements the Greeter interface, hence the two template parameters. The constructor takes a feature string, in this case "en", that can be used later for named construction of objects. The address of the BasicPlugin is then placed in the PluginList, so it can be resolved by the loader code. This is pretty much all you need to do to write a plugin. If we decide to write a GermanGreeter and FrenchGreeter later and do not want to compile them into a separate file we can simply add them to the PluginList. Instead of using the BasicPlugin template, we can derive from Pt::Plugin and override the create and destroy methods if we need a special way of creating or destroying. BasicPlugin is derived from Pt::Plugin and simply creates with new and destroys with delete.</p>
<h1><a class="anchor" id="plugins_LoadingPlugins"></a>
Loading Plugins</h1>
<p>To load a plugin in an application the PluginManager class is used. It is a class template that takes the Interface type, here Greeter, as parameter. It will load the plugin, resolve the pluginlist and get the plugins to be used when a class needs to be created. It is very simple to use:</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1System_1_1PluginManager.html">Pt::System::PluginManager&lt;Greeter&gt;</a> manager;</div>
<div class="line">manager.<a class="code" href="classPt_1_1System_1_1PluginManager.html#a1562979c20c90c014bc08523b8888596">loadPlugin</a>(<span class="stringliteral">&quot;PluginList&quot;</span>, <span class="stringliteral">&quot;/path/to/plugin.so&quot;</span>);</div>
<div class="line"></div>
<div class="line">Greeter* greeter = manager.<a class="code" href="classPt_1_1System_1_1PluginManager.html#afa3ecc224c3b9f40227d0ee550d0bd74">create</a>(<span class="stringliteral">&quot;en&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(greeter)</div>
<div class="line">{</div>
<div class="line">    greeter-&gt;sayHello();</div>
<div class="line">    manager.<a class="code" href="classPt_1_1System_1_1PluginManager.html#ae2804daea3ef25a15734219c825cac28">destroy</a>(greeter);</div>
<div class="line">}</div>
</div><!-- fragment --><p>First we need to load the shared library with PluginManager::loadPlugin(). Then we can create an instance of a Greeter by a feature string by calling PluginManager::create(). Normally, one would ask the user for a language and then see if we can create a Greeter. if the instance could be created we use it like a normal C++ class, but not delete it directly and instead use the PluginManager::destroy() method. The rationale behind this is that the allocator in a shared library can differ from the allocator in the application and the same code needs to delete it, which created it. The life-time of the created classes is bound to the life-time of the PluginManager. When the PluginManager goes out of scope it will not only destroy all created instances, it will also unload all loaded plugin libraries. </p>
</div></div><!-- contents -->

<div class="clear">&nbsp;</div>
<div id="footer">
	<div style="float:left;">Copyright &copy; 2003-2014 The Pt Development Team</div>
</div>
</div>
</body>
</html>
