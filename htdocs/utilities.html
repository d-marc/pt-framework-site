<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Utilities</title>
  <meta content="Pt Reference Manual" name="description">
  <meta content="The Pt Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body style="margin:0px;">
<div id="container">
<div id="top"> <!-- do not remove this div, it is closed by doxygen! -->
<div id="header">
    <table id="logo">
        <tr>
            <td>
                <a href="../index.html"><img src="platinum-logo.gif" border="0"/></a>
            </td>
            <td>
                <h3>The Power in your Hands</h3>
            </td>
        </tr>
    </table>
    <div class="search">
        <form action="http://search.freefind.com/find.html" method="get" accept-charset="utf-8" target="_self">
          <p style="margin: 0; padding-top:2px; padding-bottom:2px;"><b>Search Site:</b></p>
          <p style="margin: 0; padding:0;">
            <input type="hidden" name="si" value="43943317">
            <input type="hidden" name="pid" value="r">
            <input type="hidden" name="n" value="0">
            <input type="hidden" name="_charset_" value="">
            <input type="hidden" name="bcd" value="&#247;">
            <input style="background-color: #FFFFFF;
                          border: 1px solid #ffffff;
                          font-size: 12px;
                          width: 160px"
                   type="text" name="query" value="Search...">
          </p>
        </form>
    </div>
	<div class="header-menu">
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../index.html">About</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../features-modules.html">Features</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../docs.html">Documentation</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../downloads.html">Download</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../community.html">Community</a> </div>
	</div>
  </div>
<div class="header-submenu" style="padding-left: 146px;">  
    <div class="header-submenu-term"><img src="sub_left.png" width="4" height="20" /></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="../docs.html">Main</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="classes.html">Classes</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="namespaces.html">Namespaces</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="modules.html">Modules</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-term"><img src="sub_right.png" width="4" height="20" /></div>
</div>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Utilities </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The conversion utilities of the Platinum core library include functions to convert <a class="el" href="utilities.html#utilities_ByteOrder">byte orders</a>, to format and parse <a class="el" href="utilities.html#utilities_StringConv">numbers</a>, and to perform checked <a class="el" href="utilities.html#utilities_NumConv">numeric conversions</a>.</p>
<p>Basic application support is provided by the <a class="el" href="classPt_1_1Arg.html" title="Read and extract command-line options. ">Pt::Arg</a> class and the <a class="el" href="classPt_1_1Settings.html" title="Store application settings. ">Pt::Settings</a> class. The first one is a convenient way to parse and process program options and the latter one allows to load and store application settings in files or other places.</p>
<p>Two types are useful to get type information <a class="el" href="structPt_1_1TypeTraits.html" title="Traits for type properties. ">Pt::TypeTraits</a> and <a class="el" href="classPt_1_1TypeInfo.html" title="Extended API for std::type_info. ">Pt::TypeInfo</a>. TypeTraits are used for generic programming, for example to deduce the pointer type in templated code, or to branch differently for const and non-const types. The TypeInfo class is a wrapper for std::type_info, which makes it easier to store and compare type information. The std::type_info is normally not copyable and comparable. <a class="el" href="classPt_1_1SourceInfo.html" title="Source code info class. ">Pt::SourceInfo</a> is used to store information about a location in the source code.</p>
<h1><a class="anchor" id="utilities_StringConv"></a>
String Conversions</h1>
<p>The framework includes functions for fast conversion between strings and numbers. The overloaded functions <a class="el" href="group__Utilities.html#gad34360b7939bd54bea4c42b3df0283ab">parseInt()</a> and <a class="el" href="group__Utilities.html#ga3d34599303e3da18e9d1004b858e498e">formatInt()</a> convert between strings and integers, and <a class="el" href="group__Utilities.html#ga9ca4001d8fc13efc5917f2ac1058c69c">parseFloat() </a> and <a class="el" href="group__Utilities.html#gab8c23f359723f97773055b3c68f76f5d">formatFloat()</a> convert between strings and floats. The functions work with iterators as input or output instead of string objects, so they can be used with simple buffers or even streams, as shown in the following example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Pt/Convert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#incldue &lt;iterator&gt;</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#inlcude &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">std::ostream_iterator&lt;char&gt; it(std::cout);</div>
<div class="line"><a class="code" href="group__Utilities.html#ga3d34599303e3da18e9d1004b858e498e">Pt::formatInt</a>(it, 42);</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* buf = <span class="stringliteral">&quot;42&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* bufend = buf + 2;</div>
<div class="line"><span class="keywordtype">int</span> n = 0;</div>
<div class="line"><a class="code" href="group__Utilities.html#gad34360b7939bd54bea4c42b3df0283ab">Pt::parseInt</a>(buf, bufend, n);</div>
</div><!-- fragment --><p>A stream iterator is used to format a number directly to std::cout and then a number is parsed from a raw character buffer. Floating point numbers can be formatted and parsed in a similar way like integers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Pt/Convert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#incldue &lt;iterator&gt;</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#inlcude &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">std::ostream_iterator&lt;char&gt; it(std::cout);</div>
<div class="line"><a class="code" href="group__Utilities.html#gab8c23f359723f97773055b3c68f76f5d">Pt::formatFloat</a>(it, 42.123);</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* buf = <span class="stringliteral">&quot;42.123&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* bufend = buf + 6;</div>
<div class="line"><span class="keywordtype">int</span> f = 0;</div>
<div class="line"><a class="code" href="group__Utilities.html#ga9ca4001d8fc13efc5917f2ac1058c69c">Pt::parseFloat</a>(buf, bufend, f);</div>
</div><!-- fragment --><p>By default, decimal format will be used when numbers are parsed and formatted, but overloads exist that accept an additional format object. A few format objects are already provided by the framwork, named Pt::DecimalFormat, Pt::OctalFormat, Pt::HexFormat or Pt::BinaryFormat, which allow numeric conversion in a different base. The next example shows how integers in hex format can be parsed and formatted:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Pt/Convert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#incldue &lt;iterator&gt;</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line">Pt::HexFormat&lt;char&gt; fmt;</div>
<div class="line"></div>
<div class="line">std::ostream_iterator&lt;char&gt; it(std::cout);</div>
<div class="line"><a class="code" href="group__Utilities.html#ga3d34599303e3da18e9d1004b858e498e">Pt::formatInt</a>(it, 0x42, fmt);</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* buf = <span class="stringliteral">&quot;0x42&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* bufend = buf + 4;</div>
<div class="line"><span class="keywordtype">int</span> n = 0;</div>
<div class="line"><a class="code" href="group__Utilities.html#gad34360b7939bd54bea4c42b3df0283ab">Pt::parseInt</a>(buf, bufend, n, fmt);</div>
</div><!-- fragment --><p>All parse functions used so far throw an exception of type <a class="el" href="classPt_1_1ConversionError.html" title="Indicates a failed conversion. ">Pt::ConversionError</a>, if the conversion failed. Overloads of the parse functions are available, which set a bool flag instead, to indicate a conversion error. Both, the format and parse functions return an iterator pointing to the position after the last character that was written or read, respectively. Partial consumption of the input is not treated as an error.</p>
<h1><a class="anchor" id="utilities_NumConv"></a>
Numeric Conversions</h1>
<p>Numeric assignments can lead to loss of data, if the operation narrows the data type to a smaller one. For example, numeric conversion from int to short can be an error, if the assigned value exceeds the maximum or minimum value possible for shorts. The <a class="el" href="group__Utilities.html#ga7c5b9a08aceaff4a18ad274153c02c1a" title="Checked numeric conversion. ">narrow()</a> function can be used instead of normal assignment, to protect against this. In case of an error, an exception of type <a class="el" href="classPt_1_1ConversionError.html" title="Indicates a failed conversion. ">Pt::ConversionError</a> is thrown.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Pt/Convert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">long</span> l = ...;</div>
<div class="line"><span class="keywordtype">short</span> s = 0;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    s = Pt::narrow&lt;short&gt;(l);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> <a class="code" href="classPt_1_1ConversionError.html">Pt::ConversionError</a>&amp; e)</div>
<div class="line">{</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;numeric value is out of range: &quot;</span> &lt;&lt; l &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="utilities_ByteOrder"></a>
Byte Order Conversion</h1>
<p>The byteorder conversion API consists of two sets of functions. The <a class="el" href="group__Utilities.html#ga630b14e1adebb2ab0e59ea1af2f7c3ac" title="Swaps the byteorder of an int32_t. ">swab()</a> function is able to swap the byteorder of a type by bytewise copying as shown in the following example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Pt/Byteorder.h&gt;</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__BasicTypes.html#ga435d1572bf3f880d55459d9805097f62">Pt::uint32_t</a> value = ...;</div>
<div class="line"><a class="code" href="group__BasicTypes.html#ga435d1572bf3f880d55459d9805097f62">Pt::uint32_t</a> swapped = <a class="code" href="group__Utilities.html#ga630b14e1adebb2ab0e59ea1af2f7c3ac">Pt::swab</a>(value);</div>
</div><!-- fragment --><p>The <a class="el" href="group__Utilities.html#ga630b14e1adebb2ab0e59ea1af2f7c3ac" title="Swaps the byteorder of an int32_t. ">swab()</a> function is overloaded for all fixed-size integer types such as <a class="el" href="group__BasicTypes.html#ga435d1572bf3f880d55459d9805097f62" title="Unsigned 32-bit integer type. ">Pt::uint32_t</a>. A second set of functions can be used to convert from a specific external byteorder to the native host byteorder:</p>
<ul>
<li><a class="el" href="group__Utilities.html#ga83bc0daa86a89543b86dbae165ab9a4c" title="Converts a value from big-endian to host-byteorder. ">Pt::beToHost()</a></li>
<li><a class="el" href="group__Utilities.html#gab2008e7b981ad12830b00e2115b3d063" title="Converts a value from the host-byteorder to big-endian. ">Pt::hostToBe()</a></li>
<li><a class="el" href="group__Utilities.html#gae052a9e568c7a59117411e25f191ef49" title="Converts a value from little-endian to host-byteorder. ">Pt::leToHost()</a></li>
<li><a class="el" href="group__Utilities.html#ga1edda5ac54b0a328707546e32d8af2c5" title="Converts a value from host-byteorder to little-endian. ">Pt::hostToLe()</a></li>
</ul>
<p>For example the function <a class="el" href="group__Utilities.html#ga83bc0daa86a89543b86dbae165ab9a4c" title="Converts a value from big-endian to host-byteorder. ">beToHost()</a> converts from big-endian to the host byte order:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Pt/Byteorder.h&gt;</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__BasicTypes.html#ga435d1572bf3f880d55459d9805097f62">Pt::uint32_t</a> beVal = ...;</div>
<div class="line"><a class="code" href="group__BasicTypes.html#ga435d1572bf3f880d55459d9805097f62">Pt::uint32_t</a> value = <a class="code" href="group__Utilities.html#ga83bc0daa86a89543b86dbae165ab9a4c">Pt::beToHost</a>(beVal);</div>
</div><!-- fragment --><h1><a class="anchor" id="utilities_Arg"></a>
Command Line Arguments</h1>
<p>Arg objects can be used to process command line options passed to the main function of the program. A syntax for short-named and long-named options is supported. Short-named options start with a single hypen followd by a character (-O). Optionally, a value follows directly (-Ofoo) or separated by whitespace(-O foo). Alternatively, option names can be consist of any character sequence to support unix style options(&ndash;option) and windows style options (/OPTION). An optional value follows either separated by whitespace (&ndash;option yes) or an equal character (/OPTION=yes). Note that constructing an Arg from with the character 'n' or with the string "-n" are equivalent.</p>
<p>The template parameter of the Arg class is the argument value type, which must be streamable, i.e. the operator &gt;&gt; (std::istream&amp;, T&amp;) must be defined for the type T. When an Arg is constructed, the operator will be used to extract the value from the command-line string. the next example demonstrates this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1Arg.html">Pt::Arg&lt;int&gt;</a> option_n(argc, argv, <span class="charliteral">&#39;n&#39;</span>, 0);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;value for -n: &quot;</span> &lt;&lt; option_n &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Options are removed from the option-list, so programs can easily check, if there are parameters left, after all options were extracted. A specialization exists for boolean parameters. This implements a switch, which is on, if the option is present and off, if it is missing. The option consists, in this case, only of a command line flag without a value. Boolean parameters can also be grouped, so -abc is processed like -a -b -c.</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1Arg.html">Pt::Arg&lt;bool&gt;</a> debug(argc, argv, <span class="stringliteral">&quot;--debug&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (debug)</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;debug flag is set&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The example shown above not only shows a boolean parameter, but also how long-named options are handled, in this case "--debug".</p>
<h1><a class="anchor" id="utilities_Settings"></a>
Application Settings</h1>
<p>Many programs need to be able to restore its settings from a persistent location, such as a file. The <a class="el" href="classPt_1_1Settings.html">Settings</a> class provides an hierachical organisation of settings entries and an API to read and write them in a text format. The following example illustrates how settings can be read from a file:</p>
<div class="fragment"><div class="line">std::ifstream ifs(<span class="stringliteral">&quot;app.settings&quot;</span>);</div>
<div class="line"><a class="code" href="classPt_1_1TextIStream.html">Pt::TextIStream</a> tis(ifs, <span class="keyword">new</span> Pt::Utf8codec);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1Settings.html">Pt::Settings</a> settings;</div>
<div class="line">settings.<a class="code" href="classPt_1_1Settings.html#ae73562d96ab1e249b02b6026c3accfa5">load</a>(tis);</div>
</div><!-- fragment --><p>Settings can be loaded from any input stream, so the API is not limited to files. In this example, a file stream is opened and a text input stream is used to read UTF-8 encoded text. Another interesting use-case is to load settings from a string stream, which can greatly simplify unit testing. Writing settings to a file is just as easy:</p>
<div class="fragment"><div class="line">std::ofstream ofs(<span class="stringliteral">&quot;app.settings&quot;</span>, std::ios::out|std::ios::trunc);</div>
<div class="line"><a class="code" href="classPt_1_1TextOStream.html">Pt::TextOStream</a> tos(ofs, <span class="keyword">new</span> Pt::Utf8codec);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1Settings.html">Pt::Settings</a> settings;</div>
<div class="line">settings.<a class="code" href="classPt_1_1Settings.html#a49f370ed56c9f0e4e239cba5b04d8097">save</a>(tos);</div>
</div><!-- fragment --><p>Any output stream can be used to save the settings, in this case UTF-8 encoded text is written to a file. Note, that the file is truncated when opened, so the content is replaced.</p>
<p>Settings are saved in a compact text format, which supports integers, floats, strings and booleans as scalar value types and arrays and structs as compound types. The next example shows some possibilities:</p>
<div class="fragment"><div class="line">a = 1</div>
<div class="line">b = 3.14</div>
<div class="line">c = <span class="stringliteral">&quot;Hello World!&quot;</span></div>
<div class="line">d = <span class="keyword">true</span></div>
<div class="line">e = [ 1, 2, 3 ]</div>
<div class="line">f = { red = 255, green = 0, blue = 0 }</div>
</div><!-- fragment --><p>The entry values for a, b, c and d are of type integer, float, string and bool, respectively. The entries e and f demonstrate the syntax for arrays and structs. The following example shows how such a settings file can be loaded and how the entries are accessed:</p>
<div class="fragment"><div class="line">std::ifstream ifs(<span class="stringliteral">&quot;app.settings&quot;</span>);</div>
<div class="line"><a class="code" href="classPt_1_1TextIStream.html">Pt::TextIStream</a> tis(ifs, <span class="keyword">new</span> Pt::Utf8codec);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1Settings.html">Pt::Settings</a> settings;</div>
<div class="line">settings.<a class="code" href="classPt_1_1Settings.html#ae73562d96ab1e249b02b6026c3accfa5">load</a>(tis);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line"><span class="keywordtype">bool</span> ok = settings[<span class="stringliteral">&quot;a&quot;</span>].get(a);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">float</span> b = 0;</div>
<div class="line">ok = settings.<a class="code" href="classPt_1_1Settings.html#aea2a15231a6825e1a0f3f83f2c048366">entry</a>(<span class="stringliteral">&quot;b&quot;</span>).<a class="code" href="classPt_1_1Settings_1_1ConstEntry.html#aa39c5b747f7c633ad2eb3eb6288f0fbf">get</a>(b);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1String.html">Pt::String</a> c;</div>
<div class="line">ok = settings.<a class="code" href="classPt_1_1Settings.html#aea2a15231a6825e1a0f3f83f2c048366">entry</a>(<span class="stringliteral">&quot;c&quot;</span>).<a class="code" href="classPt_1_1Settings_1_1ConstEntry.html#aa39c5b747f7c633ad2eb3eb6288f0fbf">get</a>(c);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> d = <span class="keyword">false</span>;</div>
<div class="line">ok = settings.<a class="code" href="classPt_1_1Settings.html#aea2a15231a6825e1a0f3f83f2c048366">entry</a>(<span class="stringliteral">&quot;d&quot;</span>).<a class="code" href="classPt_1_1Settings_1_1ConstEntry.html#aa39c5b747f7c633ad2eb3eb6288f0fbf">get</a>(d);</div>
<div class="line"></div>
<div class="line">std::vector&lt;int&gt; e;</div>
<div class="line">ok = settings.<a class="code" href="classPt_1_1Settings.html#aea2a15231a6825e1a0f3f83f2c048366">entry</a>(<span class="stringliteral">&quot;e&quot;</span>).<a class="code" href="classPt_1_1Settings_1_1ConstEntry.html#aa39c5b747f7c633ad2eb3eb6288f0fbf">get</a>(e);</div>
<div class="line"></div>
<div class="line">Color f;</div>
<div class="line">ok = settings.<a class="code" href="classPt_1_1Settings.html#aea2a15231a6825e1a0f3f83f2c048366">entry</a>(<span class="stringliteral">&quot;f&quot;</span>).<a class="code" href="classPt_1_1Settings_1_1ConstEntry.html#aa39c5b747f7c633ad2eb3eb6288f0fbf">get</a>(f);</div>
</div><!-- fragment --><p>The <a class="el" href="classPt_1_1Settings.html#aea2a15231a6825e1a0f3f83f2c048366">entry()</a> method or alternatively, the index operator can be used, to access entries and subentries by name. If a subentry does not exist, an empty entry object will be returned. Values can be retrieved with the <a class="el" href="classPt_1_1Settings_1_1ConstEntry.html#aa39c5b747f7c633ad2eb3eb6288f0fbf">get()</a> method, which returns false, if the value does not exist. The data type, which is stored in the settings must be serializable i.e. the serialization operators must be defined. The framework defines the serialization operators for STL containers, so these work out of the box. The <a class="el" href="classPt_1_1Settings_1_1Entry.html#ac492aea31d0904792242257fdcb1e197">set()</a> function can be used to set an entry to a new value, before the modified settings are saved. New subentries can be added using the <a class="el" href="classPt_1_1Settings.html#a84d4425d49ab42bb6e85870695fa84e4">addEntry()</a> function.</p>
<p>Settings can be split into sections, to improve the readability of the file, using the following syntax:</p>
<div class="fragment"><div class="line">[animals]</div>
<div class="line">a = <span class="stringliteral">&quot;dog&quot;</span></div>
<div class="line">b = <span class="stringliteral">&quot;cat&quot;</span></div>
<div class="line"></div>
<div class="line">[plants]</div>
<div class="line">a = <span class="stringliteral">&quot;tulip&quot;</span></div>
<div class="line">b = <span class="stringliteral">&quot;rose&quot;</span></div>
</div><!-- fragment --><p>When such a settings file is loaded, it will contain two entries named "animals" and "plants". Both entries will have two subentries named "a" and "b".</p>
<h1><a class="anchor" id="utilities_SourceInfo"></a>
Source Information</h1>
<p>The SourceInfo class is used to store information about a location in the source code. This includes the file name, the line number and the name of the function. The PT_SOURCEINFO macro can be used to construct a SourceInfo object conveniently, based on compiler macros such as __FILE__ or __LINE__.</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1SourceInfo.html">Pt::SourceInfo</a> si(PT_SOURCEINFO);</div>
<div class="line"></div>
<div class="line"><span class="comment">// print file, line and function</span></div>
<div class="line">std::cout &lt;&lt; si.file() &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; si.line() &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; si.func() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Note, that the SourceInfo will contain the file and line information of the location where the PT_SOURCEINFO macro is used.</p>
<h1><a class="anchor" id="utilities_TypeInfo"></a>
Type Information</h1>
<p>The normal std::type_info class is not copyable, so only raw pointers can be stored in containers such as std::vector. The TypeInfo class addresses this problem, by wrapping std::type_info into a type with value semantics. It also adds comparison operators, like less-than comparison, which allow to use it as the key for assoziative containers:</p>
<div class="fragment"><div class="line"><span class="comment">// OK, TypeInfo is copyable</span></div>
<div class="line">std::vector&lt;Pt::TypeInfo&gt; typeVector;</div>
<div class="line"></div>
<div class="line"><span class="comment">// OK, TypeInfo is less-than comparable</span></div>
<div class="line">std::map&lt;Pt::TypeInfo, std::string&gt; typeMap;</div>
</div><!-- fragment --> </div></div><!-- contents -->

<div class="clear">&nbsp;</div>
<div id="footer">
	<div style="float:left;">Copyright &copy; 2003-2014 The Pt Development Team</div>
</div>
</div>
</body>
</html>
