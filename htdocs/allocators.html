<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Allocators</title>
  <meta content="Pt Reference Manual" name="description">
  <meta content="The Pt Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body style="margin:0px;">
<div id="container">
<div id="top"> <!-- do not remove this div, it is closed by doxygen! -->
<div id="header">
    <table id="logo">
        <tr>
            <td>
                <a href="../index.html"><img src="platinum-logo.gif" border="0"/></a>
            </td>
            <td>
                <h3>The Power in your Hands</h3>
            </td>
        </tr>
    </table>
    <div class="search">
        <form action="http://search.freefind.com/find.html" method="get" accept-charset="utf-8" target="_self">
          <p style="margin: 0; padding-top:2px; padding-bottom:2px;"><b>Search Site:</b></p>
          <p style="margin: 0; padding:0;">
            <input type="hidden" name="si" value="43943317">
            <input type="hidden" name="pid" value="r">
            <input type="hidden" name="n" value="0">
            <input type="hidden" name="_charset_" value="">
            <input type="hidden" name="bcd" value="&#247;">
            <input style="background-color: #FFFFFF;
                          border: 1px solid #ffffff;
                          font-size: 12px;
                          width: 160px"
                   type="text" name="query" value="Search...">
          </p>
        </form>
    </div>
	<div class="header-menu">
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../index.html">About</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../features-modules.html">Features</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../docs.html">Documentation</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../downloads.html">Download</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../community.html">Community</a> </div>
	</div>
  </div>
<div class="header-submenu" style="padding-left: 146px;">  
    <div class="header-submenu-term"><img src="sub_left.png" width="4" height="20" /></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="../docs.html">Main</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="classes.html">Classes</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="namespaces.html">Namespaces</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="modules.html">Modules</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-term"><img src="sub_right.png" width="4" height="20" /></div>
</div>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Allocators </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="classPt_1_1Allocator.html" title="Allocator interface. ">Pt::Allocator</a> interface can be used to optimize or customize allocation strategies. Two allocators are provided, which can be approached by the Allocator interface, a pool based allocator and a page based allocator. A pool based allocator is beneficial in all cases where many small objects of small sizes are created. This is for example used to optimize memory usage during serialization. The page based allocator simply places data consecutively in memory and frees the whole block when its no longer in use. This is useful in situations where chunks of memory or objects are created and destroyed at the same time.</p>
<h1><a class="anchor" id="allocators_Interface"></a>
The Allocator Interface</h1>
<p>Allocators allow a program to use different methods of allocating and deallocating raw memory. The default implementation will simply use new and delete. Custom allocators are implemented by overriding the two methods <a class="el" href="classPt_1_1Allocator.html#a6af3b3e52c8986cc067b47cf0be378c2">allocate()</a> and <a class="el" href="classPt_1_1Allocator.html#a1783ebebe4aabff1b4fe4866c1dbcdcf">deallocate()</a> of the <a class="el" href="classPt_1_1Allocator.html" title="Allocator interface. ">Pt::Allocator</a> base class. The following example tracks the amount of allocated memory:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CheckedAllocator : <span class="keyword">public</span> <a class="code" href="classPt_1_1Allocator.html">Pt::Allocator</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        CheckedAllocator()</div>
<div class="line">        : _allocated(0)</div>
<div class="line">        {}</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span>* <a class="code" href="classPt_1_1Allocator.html#a6af3b3e52c8986cc067b47cf0be378c2">allocate</a>(std::size_t size)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">void</span>* p = <a class="code" href="classPt_1_1Allocator.html#a6af3b3e52c8986cc067b47cf0be378c2">Pt::Allocator::allocate</a>(size);</div>
<div class="line">            _allocated += size;</div>
<div class="line">            <span class="keywordflow">return</span> p; </div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPt_1_1Allocator.html#a1783ebebe4aabff1b4fe4866c1dbcdcf">deallocate</a>(<span class="keywordtype">void</span>* p, std::size_t size)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classPt_1_1Allocator.html#a1783ebebe4aabff1b4fe4866c1dbcdcf">Pt::Allocator::deallocate</a>(p, size);</div>
<div class="line">            _allocated -= size;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        std:<span class="keywordtype">size_t</span> allocated()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{ <span class="keywordflow">return</span> _allocated; }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        std::size_t _allocated;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This interface differs from std::allocator used for STL containers, because it allows to allocate memory of different sizes through the same interface. The std::allocator is meant to allocate and also construct objects of the same size. It is however possible, to implement a std::allocator using the raw memory allocators described here.</p>
<h1><a class="anchor" id="allocators_Pool"></a>
Pool Allocation</h1>
<p>The <a class="el" href="classPt_1_1PoolAllocator.html">PoolAllocator</a> uses pools to allocate memory. Each pool consists of blocks of equally sized records, which can be used for allocations up to the size of a record. The record sizes increase from pool to pool. When memory is allocated, a record is used from the pool, which handles the requested size. When memory is deallocated, the record is returned to the corresponding pool. This method of allocation is effective, because larger blocks of memory are allocated and then reused in the form of many smaller records. An advantage of this kind of allocator, compared to free list based allocators, is that it is able to release completely unused blocks.</p>
<div class="fragment"><div class="line"><span class="comment">// Contruct with max. record size, alignment and block size</span></div>
<div class="line"><a class="code" href="classPt_1_1PoolAllocator.html">Pt::PoolAllocator</a> allocator(32, 8, 4096);</div>
<div class="line"></div>
<div class="line"><span class="comment">// will use a record from the pools</span></div>
<div class="line"><span class="keywordtype">void</span>* p1 = allocator.allocate( <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) );</div>
<div class="line"></div>
<div class="line"><span class="comment">// too large, will use operator new</span></div>
<div class="line"><span class="keywordtype">void</span>* p2 = allocator.allocate( 64 );</div>
</div><!-- fragment --><p>When a PoolAllocator is constructed, the maximum size for records has to be specified. The reason for this is that this type of allocator is ineffective for large allocations. Therefore, memory which is larger than this limit will be allocated using the new operator, instead of a record from a memory pool. Optionally, the alignment and the maximum block size can be set. The record sizes of the pools will be multiples of the alignment. So if the alignment is 8, the first pool will have records of size 8, the second pool records of size 16 and so forth, until the maximum size is reached. The maximum block size controls the number of records per block. A new block of records is added, when a pool is depleted and has to be extended to allow more allocations.</p>
<p>If memory of uniform sizes has to be allocated, a <a class="el" href="classPt_1_1MemoryPool.html">MemoryPool </a> can be used directly, rather than indirectly as part of the <a class="el" href="classPt_1_1PoolAllocator.html">PoolAllocator</a>. This can be faster, because the PoolAllocator has to look up the pool for the requested size of memory each time it allocates and deallocates. To construct a MemoryPool, the size of the records, i.e. the size of memory it can allocate, has to be specified.</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1MemoryPool.html">Pt::MemoryPool</a> pool( <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), 4096 );</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span>* p = pool.allocate();</div>
<div class="line"><span class="keywordtype">float</span>* f = <span class="keyword">new</span> (p) <span class="keywordtype">float</span>(3.1415);</div>
<div class="line"></div>
<div class="line">pool.deallocate(f);</div>
</div><!-- fragment --><p>Optionally, the maximum size of the blocks in the pool can be controlled. In the example shown above, the pool can only allocate memory of the size required for a float. Each time the pool itself requires more memory, it will allocate a new block of 4096 bytes.</p>
<h1><a class="anchor" id="allocators_Page"></a>
Page Allocation</h1>
<p>The <a class="el" href="classPt_1_1PageAllocator.html">PageAllocator</a> is useful, when chunks of memory have to be allocated, that can be released simultaneously. This allows the PageAllocator to allocate memory consecutively on pages and simply release all pages together at the end. Therefore, <a class="el" href="classPt_1_1PageAllocator.html#aa4377c938fe183435f7f4cfaa5227073">deallocate()</a> will not do anything, but memory will only eventually be released, when <a class="el" href="classPt_1_1PageAllocator.html#ac8bb3912a3ce86b15842e79d0b421204">clear()</a> is called or the PageAllocator is destructed. The next example illustrates this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> useAllocator(<a class="code" href="classPt_1_1Allocator.html">Pt::Allocator</a>&amp; a)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span>(std::size_t n = 1; n &lt; 16; ++n)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">void</span>* p = a.<a class="code" href="classPt_1_1Allocator.html#a6af3b3e52c8986cc067b47cf0be378c2">allocate</a>(n);</div>
<div class="line"></div>
<div class="line">        ...</div>
<div class="line"></div>
<div class="line">        <span class="comment">// won&#39;t do anything if it&#39;s a PoolAllocator</span></div>
<div class="line">        a.<a class="code" href="classPt_1_1Allocator.html#a1783ebebe4aabff1b4fe4866c1dbcdcf">deallocate</a>(p, n);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1PageAllocator.html">Pt::PageAllocator</a> allocator;</div>
<div class="line"></div>
<div class="line">useAllocator(allocator);</div>
<div class="line"></div>
<div class="line"><span class="comment">// release all allocated memory</span></div>
<div class="line">allocator.<a class="code" href="classPt_1_1PageAllocator.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a>();</div>
</div><!-- fragment --> </div></div><!-- contents -->

<div class="clear">&nbsp;</div>
<div id="footer">
	<div style="float:left;">Copyright &copy; 2003-2014 The Pt Development Team</div>
</div>
</div>
</body>
</html>
