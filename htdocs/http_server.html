<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>HTTP Server and Services</title>
  <meta content="Pt Reference Manual" name="description">
  <meta content="The Pt Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body style="margin:0px;">
<div id="container">
<div id="top"> <!-- do not remove this div, it is closed by doxygen! -->
<div id="header">
    <table id="logo">
        <tr>
            <td>
                <a href="../index.html"><img src="platinum-logo.gif" border="0"/></a>
            </td>
            <td>
                <h3>The Power in your Hands</h3>
            </td>
        </tr>
    </table>
    <div class="search">
        <form action="http://search.freefind.com/find.html" method="get" accept-charset="utf-8" target="_self">
          <p style="margin: 0; padding-top:2px; padding-bottom:2px;"><b>Search Site:</b></p>
          <p style="margin: 0; padding:0;">
            <input type="hidden" name="si" value="43943317">
            <input type="hidden" name="pid" value="r">
            <input type="hidden" name="n" value="0">
            <input type="hidden" name="_charset_" value="">
            <input type="hidden" name="bcd" value="&#247;">
            <input style="background-color: #FFFFFF;
                          border: 1px solid #ffffff;
                          font-size: 12px;
                          width: 160px"
                   type="text" name="query" value="Search...">
          </p>
        </form>
    </div>
	<div class="header-menu">
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../index.html">About</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../features-modules.html">Features</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../docs.html">Documentation</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../downloads.html">Download</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../community.html">Community</a> </div>
	</div>
  </div>
<div class="header-submenu" style="padding-left: 146px;">  
    <div class="header-submenu-term"><img src="sub_left.png" width="4" height="20" /></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="../docs.html">Main</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="classes.html">Classes</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="namespaces.html">Namespaces</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="modules.html">Modules</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-term"><img src="sub_right.png" width="4" height="20" /></div>
</div>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">HTTP Server and Services </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="http_server_service"></a>
Implementing Services</h1>
<p>The HTTP server dispatches incoming requests to services. It is the task of the service to process the request and build a reply. The service will do so by assigning a responder to the request to respond with a reply. The following example shows a simple responder, which always replies with the string "Hello World!":</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>HelloResponder : <span class="keyword">public</span> <a class="code" href="classPt_1_1Http_1_1Responder.html">Pt::Http::Responder</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        HelloResponder(<a class="code" href="classPt_1_1Http_1_1Service.html">Pt::Http::Service</a>&amp; s)</div>
<div class="line">        : Pt::Http::Responder(s)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPt_1_1Http_1_1Responder.html#ac42e9083a591870e368f493985579698">onBeginRequest</a>(<a class="code" href="classPt_1_1Http_1_1Request.html">Pt::Http::Request</a>&amp; request, <a class="code" href="classPt_1_1Http_1_1Reply.html">Pt::Http::Reply</a>&amp; reply, <a class="code" href="classPt_1_1System_1_1EventLoop.html">Pt::System::EventLoop</a>&amp; loop)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPt_1_1Http_1_1Responder.html#a6989d7f431a372e1c9c81e1f2fff6722">onReadRequest</a>(<a class="code" href="classPt_1_1Http_1_1Request.html">Pt::Http::Request</a>&amp; request, <a class="code" href="classPt_1_1Http_1_1Reply.html">Pt::Http::Reply</a>&amp; reply, <a class="code" href="classPt_1_1System_1_1EventLoop.html">Pt::System::EventLoop</a>&amp; loop)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPt_1_1Http_1_1Responder.html#aa6c918c8e26b98c18fb24a4b252ecf3e">onBeginReply</a>(<span class="keyword">const</span> <a class="code" href="classPt_1_1Http_1_1Request.html">Pt::Http::Request</a>&amp; request, <a class="code" href="classPt_1_1Http_1_1Reply.html">Pt::Http::Reply</a>&amp; reply, <a class="code" href="classPt_1_1System_1_1EventLoop.html">Pt::System::EventLoop</a>&amp; loop)</div>
<div class="line">        {</div>
<div class="line">            reply.<a class="code" href="classPt_1_1Http_1_1Message.html#aae56e96375ec31f762b40b8ff136f39b">body</a>() &lt;&lt; <span class="stringliteral">&quot;Hello World!&quot;</span>;</div>
<div class="line">            reply.<a class="code" href="classPt_1_1Http_1_1Reply.html#ae7e1db76e3a5162a4cf8c80b8a9289d8">beginSend</a>(<span class="keyword">true</span>); </div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPt_1_1Http_1_1Responder.html#a093bd5e0d28dcfba374d4843c1cf7f98">onWriteReply</a>(<span class="keyword">const</span> <a class="code" href="classPt_1_1Http_1_1Request.html">Pt::Http::Request</a>&amp; request, <a class="code" href="classPt_1_1Http_1_1Reply.html">Pt::Http::Reply</a>&amp; reply, <a class="code" href="classPt_1_1System_1_1EventLoop.html">Pt::System::EventLoop</a>&amp; loop)</div>
<div class="line">        { }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Every responder has to be derived from the <a class="el" href="classPt_1_1Http_1_1Responder.html" title="HTTP service responder. ">Pt::Http::Responder</a> base class and four methods have to be implemented. These methods are called in the order, in which the request and reply have to be handled. First, <a class="el" href="classPt_1_1Http_1_1Responder.html#ac42e9083a591870e368f493985579698">onBeginRequest()</a> is called, after the HTTP header of the request has been received. Responders might inspect the header fields to prepare the reply. If the request contains a body, <a class="el" href="classPt_1_1Http_1_1Responder.html#a6989d7f431a372e1c9c81e1f2fff6722">onReadRequest()</a> will called next. Note, that this method might be called multiple times, each time with the next chunk of the body. Once the request has been read completely, <a class="el" href="classPt_1_1Http_1_1Responder.html#aa6c918c8e26b98c18fb24a4b252ecf3e">onBeginReply()</a> is called, in which the reply should be started. The <a class="el" href="classPt_1_1Http_1_1Reply.html#ae7e1db76e3a5162a4cf8c80b8a9289d8">beginSend()</a> method accepts a completion flag which indicates, whether more data has to be sent. If <a class="el" href="classPt_1_1Http_1_1Reply.html#ae7e1db76e3a5162a4cf8c80b8a9289d8">beginSend()</a> is called with the completion flag set to true, the reply is considered to be finished and the responder is released. If <a class="el" href="classPt_1_1Http_1_1Reply.html#ae7e1db76e3a5162a4cf8c80b8a9289d8">beginSend()</a> is called with the completion flag set to false, <a class="el" href="classPt_1_1Http_1_1Responder.html#a093bd5e0d28dcfba374d4843c1cf7f98">onWriteReply()</a> will be called, when the server is ready to send the next chunk of body data. This allows to write large replies in chunked-encoding, which means, that the body of the reply is written in several chunks. Eventually, the responder should finish the reply by calling <a class="el" href="classPt_1_1Http_1_1Reply.html#ae7e1db76e3a5162a4cf8c80b8a9289d8">beginSend()</a> with the completion flag set to true. Generally, the reply can be sent at any stage in the process, in which case no other methods of the responder will be called and the remaining request is ignored.</p>
<p>Specific responders are used by services to reply to a request. All services have to implement the <a class="el" href="classPt_1_1Http_1_1Service.html" title="HTTP service. ">Pt::Http::Service</a> interface, which basically serves as a factory for responders. The next example shows how the HelloResponder is used by the HelloService:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>HelloService : <span class="keyword">public</span> <a class="code" href="classPt_1_1Http_1_1Service.html">Pt::Http::Service</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        HelloService()</div>
<div class="line">        { }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="keyword">virtual</span> <a class="code" href="classPt_1_1Http_1_1Responder.html">Pt::Http::Responder</a>* <a class="code" href="classPt_1_1Http_1_1Service.html#a6ba78d05d3ac202751247902423f69bb">onGetResponder</a>(<span class="keyword">const</span> <a class="code" href="classPt_1_1Http_1_1Request.html">Pt::Http::Request</a>&amp; req)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">new</span> HelloResponder(*<span class="keyword">this</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPt_1_1Http_1_1Service.html#a8e8d88c0fbe1d98fe87a2104bcc0690c">onReleaseResponder</a>(<a class="code" href="classPt_1_1Http_1_1Responder.html">Pt::Http::Responder</a>* r)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">delete</span> r;</div>
<div class="line">        }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Two factory methods have to be implemented, firstly <a class="el" href="classPt_1_1Http_1_1Service.html#a6ba78d05d3ac202751247902423f69bb">onGetResponder()</a> to create a responder to handle the incoming request and secondly <a class="el" href="classPt_1_1Http_1_1Service.html#a8e8d88c0fbe1d98fe87a2104bcc0690c">onReleaseResponder()</a> to release the responder, after the reply was sent. For simple cases, like this example, the <a class="el" href="classPt_1_1Http_1_1BasicService.html" title="Basic HTTP service implementation. ">Pt::Http::BasicService</a> template can be used:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classPt_1_1Http_1_1BasicService.html">Pt::Http::BasicService&lt;HelloResponder&gt;</a> HelloService;</div>
</div><!-- fragment --><p>The template uses an allocator to create and destroy responders. If no allocator is specified, new/delete will be used just like in the previous example. However, the service interface is usually employed to create responders depending on the request headers. It is also possible to optimize the creation of responders, for example, responders could be cached or created and released in a specific way.</p>
<h1><a class="anchor" id="http_server_servlet"></a>
Servlets and Request Dispatch</h1>
<p>A servlet determines, which requests are dispatched to a service. It combines a service with a mapping rule and can be added to a <a class="el" href="classPt_1_1Http_1_1Server.html" title="An HTTP server. ">Pt::Http::Server</a>. Services can be shared by multiple servlets, for example to make the same resources available under different names. The easiest servlet is <a class="el" href="classPt_1_1Http_1_1MapUrl.html" title="Maps requests to a service by URL. ">Pt::Http::MapUrl</a>, which maps requests for a specific URL to a service:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1System_1_1MainLoop.html">Pt::System::MainLoop</a> loop;</div>
<div class="line">        </div>
<div class="line">    <a class="code" href="classPt_1_1Net_1_1Endpoint.html">Pt::Net::Endpoint</a> ep = <a class="code" href="classPt_1_1Net_1_1Endpoint.html#a3e2a1ad7afd80765b91aaa1dac44dfad">Pt::Net::Endpoint::ip4Any</a>(80);</div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1Server.html">Pt::Http::Server</a> server(loop, ep);</div>
<div class="line">        </div>
<div class="line">    HelloService helloService;</div>
<div class="line">        </div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1MapUrl.html">Pt::Http::MapUrl</a> mapHello(<span class="stringliteral">&quot;/hello&quot;</span>, helloService);</div>
<div class="line">    server.addServlet(mapHello);</div>
<div class="line">        </div>
<div class="line">    loop.<a class="code" href="classPt_1_1System_1_1EventLoop.html#a13a43e6d814de94978c515cb084873b1">run</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The server is set up to listen on port 80. Since all operations in the server are asynchronous, an event loop is required as well. The HelloService from the previous examples is packaged in a MapUrl servlet, which maps all requests for the resource URL "/hello". Finally, the servlet is added to the server.</p>
<p>To understand how custom servlets can be implemented, it is worthwhile to look at the implementation of the MapUrl servlet. All servlets have to implement the <a class="el" href="classPt_1_1Http_1_1Servlet.html" title="Servlet for HTTP services. ">Pt::Http::Servlet</a> interface, as shown in the following example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MapUrl : <span class="keyword">public</span> <a class="code" href="classPt_1_1Http_1_1Servlet.html">Pt::Http::Servlet</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        MapUrl(<span class="keyword">const</span> std::string&amp; url, Service&amp; s)</div>
<div class="line">        : Pt::Http::Servlet(s)</div>
<div class="line">        , _url(url)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classPt_1_1Http_1_1Servlet.html#ae0d8170ad2b53d1cdb56e97e5cdae8a3">onRequest</a>(<span class="keyword">const</span> Request&amp; request)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> _url == request.url(); </div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        std::string _url;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The virtual function <a class="el" href="classPt_1_1Http_1_1Servlet.html#ae0d8170ad2b53d1cdb56e97e5cdae8a3">onRequest()</a> has to be implemented. It returns true if the request is to be dispatched to the service and false if not. In this case the request URL is compared to the mapping URL.</p>
<h1><a class="anchor" id="http_server_ssl"></a>
Secure Connections</h1>
<p>The server can be set up to only accept secure connections, which is called the HTTPS protocol. HTTPS is built upon the <a class="el" href="namespacePt_1_1Ssl.html" title="Secure Communication using SSL/TLS. ">Pt::Ssl</a> module and all one has to do, is to assign a <a class="el" href="classPt_1_1Ssl_1_1Context.html" title="Context for SSL connections. ">Pt::Ssl::Context</a> to the server as shown here:</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1Http_1_1Server.html">Pt::Http::Server</a> server;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1Ssl_1_1Context.html">Pt::Ssl::Context</a>&amp; ctx = ...;</div>
<div class="line">server.<a class="code" href="classPt_1_1Http_1_1Server.html#a08968935c2f4dee47a3c29134bc7bee4">setSecure</a>(ctx);</div>
</div><!-- fragment --><p>After <a class="el" href="classPt_1_1Http_1_1Server.html#a08968935c2f4dee47a3c29134bc7bee4">setSecure()</a> has been called, the server will only accept secure connections. Further usage of the HTTP server API is exactly the same as in case of normal HTTP.</p>
<h1><a class="anchor" id="http_server_auth"></a>
Authorization</h1>
<p>The server might request the user agent to authenticate itself, to determine whether it is authorized to access a resource. A <a class="el" href="classPt_1_1Http_1_1Authenticator.html" title="Client side authentication. ">Pt::Http::Authenticator</a> is used on the server side, to ensure that only authorized users access a resource. It serves as a base class for all kinds of authorization schemes, most notably for the <a class="el" href="classPt_1_1Http_1_1BasicAuthorizer.html" title="Server side basic HTTP authorization. ">Pt::Http::BasicAuthorizer</a>, which implements the basic authentication scheme. It needs to be subclassed further, as shown in the following example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AccessAuthorizer : <span class="keyword">public</span> BasicAuthorizer</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        AccessAuthorizer(<span class="keyword">const</span> std::string&amp; realm)</div>
<div class="line">        : BasicAuthorizer(realm)</div>
<div class="line">        {}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="keyword">virtual</span> Authorization* onAuthorizeCredentials(<span class="keyword">const</span> Credential&amp; cred, <span class="keywordtype">bool</span>&amp; granted)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// returns true if username and password are correct</span></div>
<div class="line">            granted = checkCredentials( cred.user(), cred.password() );</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> onReleaseAuthorization(Authorization* auth)</div>
<div class="line">        {}</div>
<div class="line">};</div>
</div><!-- fragment --><p>Two virtual functions need to be implemented. First, <a class="el" href="classPt_1_1Http_1_1BasicAuthorizer.html#a9de9824c2de94f2d772f2b971852a19c">onAuthorizeCredentials()</a> is called whenever user credentials have to be checked. In this example, it can immediately be determined, whether access can be granted, so a nullptr is returned and the boolean flag is set to the result of the check. The authorization can also be performed asynchronously, in which case a pointer to a <a class="el" href="classPt_1_1Http_1_1Authorization.html" title="HTTP authorization operation. ">Pt::Http::Authorization</a> object has to be returned. It is the purpose of <a class="el" href="classPt_1_1Http_1_1Authorizer.html#ae6779877e385e36d13cab075b83bc047">onReleaseAuthorization()</a> to release this object, when the operation has completed.</p>
<p>An authorizer can be assigned to a servlet, when the servlet is constructed. It is possible to use the same authorizer for multiple servlets, to have it shared. The next example shows how a servlet is constructed to use an authorizer:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1System_1_1MainLoop.html">Pt::System::MainLoop</a> loop;</div>
<div class="line"></div>
<div class="line">    AccessAuthorizer auth(<span class="stringliteral">&quot;some-realm&quot;</span>);</div>
<div class="line">        </div>
<div class="line">    <a class="code" href="classPt_1_1Net_1_1Endpoint.html">Pt::Net::Endpoint</a> ep = <a class="code" href="classPt_1_1Net_1_1Endpoint.html#a3e2a1ad7afd80765b91aaa1dac44dfad">Pt::Net::Endpoint::ip4Any</a>(80);</div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1Server.html">Pt::Http::Server</a> server(loop, ep);</div>
<div class="line">        </div>
<div class="line">    HelloService helloService;</div>
<div class="line">        </div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1MapUrl.html">Pt::Http::MapUrl</a> mapHello(<span class="stringliteral">&quot;/hello&quot;</span>, helloService, auth);</div>
<div class="line">    server.<a class="code" href="classPt_1_1Http_1_1Server.html#ac4200942695db336eb7ddc5855032035">addServlet</a>(mapHello);</div>
<div class="line">        </div>
<div class="line">    loop.<a class="code" href="classPt_1_1System_1_1EventLoop.html#a13a43e6d814de94978c515cb084873b1">run</a>();</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->

<div class="clear">&nbsp;</div>
<div id="footer">
	<div style="float:left;">Copyright &copy; 2003-2014 The Pt Development Team</div>
</div>
</div>
</body>
</html>
