<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>HTTP Clients</title>
  <meta content="Pt Reference Manual" name="description">
  <meta content="The Pt Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body style="margin:0px;">
<div id="container">
<div id="top"> <!-- do not remove this div, it is closed by doxygen! -->
<div id="header">
    <table id="logo">
        <tr>
            <td>
                <a href="../index.html"><img src="platinum-logo.gif" border="0"/></a>
            </td>
            <td>
                <h3>The Power in your Hands</h3>
            </td>
        </tr>
    </table>
    <div class="search">
        <form action="http://search.freefind.com/find.html" method="get" accept-charset="utf-8" target="_self">
          <p style="margin: 0; padding-top:2px; padding-bottom:2px;"><b>Search Site:</b></p>
          <p style="margin: 0; padding:0;">
            <input type="hidden" name="si" value="43943317">
            <input type="hidden" name="pid" value="r">
            <input type="hidden" name="n" value="0">
            <input type="hidden" name="_charset_" value="">
            <input type="hidden" name="bcd" value="&#247;">
            <input style="background-color: #FFFFFF;
                          border: 1px solid #ffffff;
                          font-size: 12px;
                          width: 160px"
                   type="text" name="query" value="Search...">
          </p>
        </form>
    </div>
	<div class="header-menu">
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../index.html">About</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../features-modules.html">Features</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../docs.html">Documentation</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../downloads.html">Download</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../community.html">Community</a> </div>
	</div>
  </div>
<div class="header-submenu" style="padding-left: 146px;">  
    <div class="header-submenu-term"><img src="sub_left.png" width="4" height="20" /></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="../docs.html">Main</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="classes.html">Classes</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="namespaces.html">Namespaces</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="modules.html">Modules</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-term"><img src="sub_right.png" width="4" height="20" /></div>
</div>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">HTTP Clients </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="http_client_send"></a>
Making HTTP Requests</h1>
<p>The class <a class="el" href="classPt_1_1Http_1_1Client.html" title="An HTTP client. ">Pt::Http::Client</a> can be used to establish a connection to an HTTP server and then send requests and receive replies. Synchronous and asynchronous operation is supported, however the latter is recommended. The following example demonstrates the asynchronous client API:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> onReplyReceived(<a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a>&amp; client);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1System_1_1MainLoop.html">Pt::System::MainLoop</a> loop;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPt_1_1Net_1_1Endpoint.html">Pt::Net::Endpoint</a> ep(<span class="stringliteral">&quot;www.google.com&quot;</span>, 80);</div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a> client(loop, ep);</div>
<div class="line">    </div>
<div class="line">    client.request().setUrl(<span class="stringliteral">&quot;/index.html&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    client.replyReceived() += Pt::slot(*<span class="keyword">this</span>, &amp;onReplyReceived);</div>
<div class="line">    client.beginReceive();</div>
<div class="line"></div>
<div class="line">    loop.<a class="code" href="classPt_1_1System_1_1EventLoop.html#a13a43e6d814de94978c515cb084873b1">run</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>An event loop is required for asynchronous operation and can be passed to the client's constructor, or set later by calling setActive(). There is no explicit connect method, because connections are established when required i.e. before the request is sent to the server, if the client is not currently connected. The target endpoint can be passed to the constructor, or set using <a class="el" href="classPt_1_1Http_1_1Client.html#a5f25e80a5fd1c2c6b2c78f5a25528d05">setHost()</a>. The member function request() returns a <a class="el" href="classPt_1_1Http_1_1Request.html" title="HTTP request message. ">Pt::Http::Request</a> object, which represents the HTTP request data to be sent to the server, including header and payload. It has to be initialized, before beginReceive() is called, to start the asynchronous HTTP communication. This usually involves setting the resource URI, HTTP method, query parameters or special header fields. The keep-alive header can be set, to request a persistent connection, which can be reused for the next request, if the server permits it. The signal replyReceived() is sent, when reply data is received from the server and ready to be processed. The next example shows the slot that prints the reply data to the standard output:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> onReplyReceived(<a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a>&amp; client)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1MessageProgress.html">Pt::Http::MessageProgress</a> progress = client.<a class="code" href="classPt_1_1Http_1_1Client.html#aa4e20e6fcca8f2a5079e2027f5b364cd">endReceive</a>();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1Reply.html">Pt::Http::Reply</a>&amp; reply = client.<a class="code" href="classPt_1_1Http_1_1Client.html#a0c5458f9aa165ddfb1b14bb741f31bde">reply</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( progress.<a class="code" href="classPt_1_1Http_1_1MessageProgress.html#a8a6fda66196cad5cddb1c14133826dec">header</a>() )</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; reply.<a class="code" href="classPt_1_1Http_1_1Reply.html#a1f37941d8633de781c0151ef00f60042">statusCode</a>() &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; reply.<a class="code" href="classPt_1_1Http_1_1Reply.html#aa2f69f8840002ae430ea491c660123d6">statusText</a>() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( progress.<a class="code" href="classPt_1_1Http_1_1MessageProgress.html#ac0b655f1fbe95c1479e5b028f2401ddc">body</a>() )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">while</span> ( reply.<a class="code" href="classPt_1_1Http_1_1Message.html#aae56e96375ec31f762b40b8ff136f39b">body</a>().rdbuf()-&gt;in_avail() )</div>
<div class="line">            std::cout &lt;&lt; reply.<a class="code" href="classPt_1_1Http_1_1Message.html#aae56e96375ec31f762b40b8ff136f39b">body</a>().get();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( progress.<a class="code" href="classPt_1_1Http_1_1MessageProgress.html#a8222e52df762c74ec229eba833a6d310">finished</a>() )</div>
<div class="line">    {</div>
<div class="line">        client.<a class="code" href="classPt_1_1Http_1_1Client.html#a43422d8f8d2418de231975ba7a025412">loop</a>()-&gt;<a class="code" href="classPt_1_1System_1_1EventLoop.html#a358d2e2397ca11ccd17553e3c40e7901">exit</a>();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#a91151db77a69a3a7a4c3ae3cabd304b7">beginReceive</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The asynchronous operation is ended by calling <a class="el" href="classPt_1_1Http_1_1Client.html#aa4e20e6fcca8f2a5079e2027f5b364cd">endReceive()</a>, which returns a <a class="el" href="classPt_1_1Http_1_1MessageProgress.html" title="HTTP message progress. ">Pt::Http::MessageProgress</a> object. It's member function finished() indicates, whether the reply was completely received. Sending a request and receiving a reply might require more than one operation. If the reply was not finished, beginReceive() has to be called again. It is possible that progress was made, but neither header nor body are available yet. In case of short messages, however, the HTTP header and the complete body are normally received at the same time. In that case, the functions header(), body() and finished() all return true and the operation has completed. If the header or body was received, the member function reply() can be used to get a <a class="el" href="classPt_1_1Http_1_1Reply.html" title="HTTP reply message. ">Pt::Http::Reply</a> object, which represents the received HTTP reply. The body of the HTTP reply can be read from an std::istream, which is obtained by calling <a class="el" href="classPt_1_1Http_1_1Message.html#aae56e96375ec31f762b40b8ff136f39b">body()</a>.</p>
<h1><a class="anchor" id="http_client_pipelining"></a>
Request Pipelining</h1>
<p>In order to pipeline HTTP requests, the client has to send multiple requests before receiving the replies. Therefore, the program must not only be notified when the reply was received, but also when the request was send to the server. More requests can then be sent, before starting to receive the replies. The following example demonstrates this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> onRequestSent(<a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a>&amp; client);</div>
<div class="line"><span class="keywordtype">void</span> onReplyReceived(<a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a>&amp; client);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1System_1_1MainLoop.html">Pt::System::MainLoop</a> loop;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPt_1_1Net_1_1Endpoint.html">Pt::Net::Endpoint</a> ep(<span class="stringliteral">&quot;animal-pics&quot;</span>, 80);</div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a> client(loop, ep);</div>
<div class="line">    </div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#aec4a4eb55d027f2e26330fbab46ebf54">request</a>().<a class="code" href="classPt_1_1Http_1_1Request.html#a4db25e46537d49db296a9889d0f1b3bc">setUrl</a>(<span class="stringliteral">&quot;/cat.png&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#afbbcffa69f59da50df8687a19808f424">requestSent</a>() += Pt::slot(*<span class="keyword">this</span>, &amp;onRequestSent);</div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#a4bc940329526f68c7a18b04f230ff84f">replyReceived</a>() += Pt::slot(*<span class="keyword">this</span>, &amp;onReplyReceived);</div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#a51f5e3c115973b763ec7ced957bc7c7c">beginSend</a>();</div>
<div class="line"></div>
<div class="line">    loop.<a class="code" href="classPt_1_1System_1_1EventLoop.html#a13a43e6d814de94978c515cb084873b1">run</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The client is set up for the initial request and the signal requestSent() is to connected to a slot, which is called when the request progressed. The asynchronous HTTP communication is then started with beginSend(). The next code block shows the code for the slot, which sends another request and then starts receiving the replies:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> onRequestSent(<a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a>&amp; client)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1MessageProgress.html">Pt::Http::MessageProgress</a> progress = client.<a class="code" href="classPt_1_1Http_1_1Client.html#abd47018d0d4fbae7e1a15807bb728662">endSend</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span>( ! progress.<a class="code" href="classPt_1_1Http_1_1MessageProgress.html#a8222e52df762c74ec229eba833a6d310">finished</a>() )</div>
<div class="line">    {</div>
<div class="line">        client.<a class="code" href="classPt_1_1Http_1_1Client.html#a51f5e3c115973b763ec7ced957bc7c7c">beginSend</a>();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( client.<a class="code" href="classPt_1_1Http_1_1Client.html#aec4a4eb55d027f2e26330fbab46ebf54">request</a>().<a class="code" href="classPt_1_1Http_1_1Request.html#a17ec4ef266a1da558331816b6c0946fb">url</a>() == <span class="stringliteral">&quot;/cat.png&quot;</span> )</div>
<div class="line">    {</div>
<div class="line">        client.<a class="code" href="classPt_1_1Http_1_1Client.html#aec4a4eb55d027f2e26330fbab46ebf54">request</a>().<a class="code" href="classPt_1_1Http_1_1Request.html#a4db25e46537d49db296a9889d0f1b3bc">setUrl</a>(<span class="stringliteral">&quot;/dog.png&quot;</span>);</div>
<div class="line">        client.<a class="code" href="classPt_1_1Http_1_1Client.html#a51f5e3c115973b763ec7ced957bc7c7c">beginSend</a>();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#a91151db77a69a3a7a4c3ae3cabd304b7">beginReceive</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The asynchronous operation is ended by calling <a class="el" href="classPt_1_1Http_1_1Client.html#abd47018d0d4fbae7e1a15807bb728662">endSend()</a>, which returns a <a class="el" href="classPt_1_1Http_1_1MessageProgress.html" title="HTTP message progress. ">Pt::Http::MessageProgress</a> object. It is possible that only a part of the request was sent and is not finished yet, in which case beginSend() is called again. If the request for the first resource has completed, the client is initialized to request the second resource asynchronously. At some point, the second request will be completely sent and beginReceive() is called to start receiving the replies. The slot connected to replyReceived() should be prepared to handle two replies, as shown in the next example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> onReplyReceived(<a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a>&amp; client)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1MessageProgress.html">Pt::Http::MessageProgress</a> progress = client.<a class="code" href="classPt_1_1Http_1_1Client.html#aa4e20e6fcca8f2a5079e2027f5b364cd">endReceive</a>();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1Reply.html">Pt::Http::Reply</a>&amp; reply = client.<a class="code" href="classPt_1_1Http_1_1Client.html#a0c5458f9aa165ddfb1b14bb741f31bde">reply</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( progress.<a class="code" href="classPt_1_1Http_1_1MessageProgress.html#a8a6fda66196cad5cddb1c14133826dec">header</a>() )</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; reply.url() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; reply.<a class="code" href="classPt_1_1Http_1_1Reply.html#aa2f69f8840002ae430ea491c660123d6">statusText</a>() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( progress.<a class="code" href="classPt_1_1Http_1_1MessageProgress.html#ac0b655f1fbe95c1479e5b028f2401ddc">body</a>() )</div>
<div class="line">    {</div>
<div class="line">        processImage( reply.<a class="code" href="classPt_1_1Http_1_1Message.html#aae56e96375ec31f762b40b8ff136f39b">body</a>() );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( progress.<a class="code" href="classPt_1_1Http_1_1MessageProgress.html#a8222e52df762c74ec229eba833a6d310">finished</a>() &amp;&amp; reply.url() == <span class="stringliteral">&quot;/dog.png&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        client.<a class="code" href="classPt_1_1Http_1_1Client.html#a43422d8f8d2418de231975ba7a025412">loop</a>()-&gt;<a class="code" href="classPt_1_1System_1_1EventLoop.html#a358d2e2397ca11ccd17553e3c40e7901">exit</a>();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#a91151db77a69a3a7a4c3ae3cabd304b7">beginReceive</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The program only exits, when the second reply was finished, otherwise beginReceive() is called repeatedly to advance the asynchronous operations to receive the replies.</p>
<h1><a class="anchor" id="http_client_chunked"></a>
Chunked Encoding</h1>
<p>To send the request body in chunked-encoding, the client has to be able to continue a send operation with the next chunk of data. The beginSend() method accepts a flag which indicates, if the request is complete or if another chunk needs to be written. The next example shows how a chunked request is started:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> onRequestSent(<a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a>&amp; client);</div>
<div class="line"><span class="keywordtype">void</span> onReplyReceived(<a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a>&amp; client);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1System_1_1MainLoop.html">Pt::System::MainLoop</a> loop;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPt_1_1Net_1_1Endpoint.html">Pt::Net::Endpoint</a> ep(<span class="stringliteral">&quot;chunks.pool&quot;</span>, 80);</div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a> client(loop, ep);</div>
<div class="line">    </div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#aec4a4eb55d027f2e26330fbab46ebf54">request</a>().<a class="code" href="classPt_1_1Http_1_1Request.html#a935f3101505bd1096a7993588d0cc49c">setMethod</a>(<span class="stringliteral">&quot;POST&quot;</span>);</div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#aec4a4eb55d027f2e26330fbab46ebf54">request</a>().<a class="code" href="classPt_1_1Http_1_1Request.html#a4db25e46537d49db296a9889d0f1b3bc">setUrl</a>(<span class="stringliteral">&quot;/chunks&quot;</span>);</div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#aec4a4eb55d027f2e26330fbab46ebf54">request</a>().<a class="code" href="classPt_1_1Http_1_1Message.html#aae56e96375ec31f762b40b8ff136f39b">body</a>() &lt;&lt; <span class="stringliteral">&quot;CHUNKS:&quot;</span>;</div>
<div class="line"></div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#afbbcffa69f59da50df8687a19808f424">requestSent</a>() += Pt::slot(*<span class="keyword">this</span>, &amp;onRequestSent);</div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#a4bc940329526f68c7a18b04f230ff84f">replyReceived</a>() += Pt::slot(*<span class="keyword">this</span>, &amp;onReplyReceived);</div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#a51f5e3c115973b763ec7ced957bc7c7c">beginSend</a>(<span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">    loop.<a class="code" href="classPt_1_1System_1_1EventLoop.html#a13a43e6d814de94978c515cb084873b1">run</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The client is prepared for a POST request with the first chunk of data in the body of the request. The important detail is that beginSend() is called with the completion flag set to false. When progress has been made, the slot connected to requestSent() will be called, which starts sending the next chunk:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> hasChunks();</div>
<div class="line"><span class="keywordtype">void</span> writeNextChunk(std::ostream&amp; os);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> onChunkedSent(<a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a>&amp; client)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1MessageProgress.html">Pt::Http::MessageProgress</a> progress = client.<a class="code" href="classPt_1_1Http_1_1Client.html#abd47018d0d4fbae7e1a15807bb728662">endSend</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span>( ! progress.<a class="code" href="classPt_1_1Http_1_1MessageProgress.html#a8222e52df762c74ec229eba833a6d310">finished</a>() )</div>
<div class="line">    {</div>
<div class="line">        client.<a class="code" href="classPt_1_1Http_1_1Client.html#a51f5e3c115973b763ec7ced957bc7c7c">beginSend</a>(<span class="keyword">false</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( hasChunks() )</div>
<div class="line">    {</div>
<div class="line">        writeNextChunk( client.<a class="code" href="classPt_1_1Http_1_1Client.html#aec4a4eb55d027f2e26330fbab46ebf54">request</a>().<a class="code" href="classPt_1_1Http_1_1Message.html#aae56e96375ec31f762b40b8ff136f39b">body</a>() );</div>
<div class="line">        client.<a class="code" href="classPt_1_1Http_1_1Client.html#a51f5e3c115973b763ec7ced957bc7c7c">beginSend</a>(<span class="keyword">false</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    client.<a class="code" href="classPt_1_1Http_1_1Client.html#a91151db77a69a3a7a4c3ae3cabd304b7">beginReceive</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <a class="el" href="classPt_1_1Http_1_1MessageProgress.html" title="HTTP message progress. ">Pt::Http::MessageProgress</a> object returned by <a class="el" href="classPt_1_1Http_1_1Client.html#abd47018d0d4fbae7e1a15807bb728662">endSend()</a> only indicates, whether a chunk has finished, not the whole request. Only a part of the chunk might have been sent, in which case beginSend() is called again to finish the chunk. If a chunk was sent completely, the code of the slot will check if more chunks have to be written and start sending them. If no more chunks have to be sent, the client starts receiving the reply, which will also finish the chunked request correctly. If pipelining of multiple chunked requests is desired, beginSend() should be called with the completion flag set to true, which terminates the request body appropriately.</p>
<h1><a class="anchor" id="http_client_ssl"></a>
Secure Connections</h1>
<p>Opening a secure HTTPS connection is fairly simple. HTTPS is built upon the <a class="el" href="namespacePt_1_1Ssl.html" title="Secure Communication using SSL/TLS. ">Pt::Ssl</a> module and all one has to do is to assign a <a class="el" href="classPt_1_1Ssl_1_1Context.html" title="Context for SSL connections. ">Pt::Ssl::Context</a> to the client as shown here:</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a> client;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1Ssl_1_1Context.html">Pt::Ssl::Context</a>&amp; ctx = ...;</div>
<div class="line">client.<a class="code" href="classPt_1_1Http_1_1Client.html#a08968935c2f4dee47a3c29134bc7bee4">setSecure</a>(ctx);</div>
</div><!-- fragment --><p>After <a class="el" href="classPt_1_1Http_1_1Client.html#a08968935c2f4dee47a3c29134bc7bee4">setSecure()</a> has been called, the client will open secure connections. Further usage of the HTTP client API is exactly the same as in case of normal HTTP.</p>
<h1><a class="anchor" id="http_client_auth"></a>
Authentication</h1>
<p>A HTTP server might respond with a "401 Authorization Required" reply with a WWW-Authenticate header, indicating that authentication is required for the requested resource. The client has then to repeat the request with appropriate credentials in the authentication headers of the request. The <a class="el" href="classPt_1_1Http_1_1Authenticator.html" title="Client side authentication. ">Pt::Http::Authenticator</a> supports user authentication for HTTP clients:</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1Http_1_1Authenticator.html">Pt::Http::Authenticator</a> auth;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1Http_1_1Credential.html">Pt::Http::Credential</a> cred(<span class="stringliteral">&quot;john&quot;</span>, <span class="stringliteral">&quot;12345&quot;</span>)</div>
<div class="line">auth.setCredentials(&quot;some-realm&quot;, cred);</div>
</div><!-- fragment --><p>First, the user credentials have to be added for the realm in which they are valid. The credentials can be used by all authentication methods. Basic authentication is supported by default, but other <a class="el" href="classPt_1_1Http_1_1Authentication.html" title="HTTP authentication for clients. ">Pt::Http::Authentication</a> methods can be added using addAuthentication(). The following example demonstrates how the request is prepared for resubmission:</p>
<div class="fragment"><div class="line"><span class="comment">// the client just received a &quot;401 Authorization Required&quot;</span></div>
<div class="line"><a class="code" href="classPt_1_1Http_1_1Client.html">Pt::Http::Client</a>&amp; client = ...;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> isAuth = auth.<a class="code" href="classPt_1_1Http_1_1Authenticator.html#addf52f8547e4a20826317bfee1abf863">authenticate</a>(client.<a class="code" href="classPt_1_1Http_1_1Client.html#aec4a4eb55d027f2e26330fbab46ebf54">request</a>(), client.<a class="code" href="classPt_1_1Http_1_1Client.html#a0c5458f9aa165ddfb1b14bb741f31bde">reply</a>());</div>
</div><!-- fragment --><p>The <a class="el" href="classPt_1_1Http_1_1Authenticator.html#addf52f8547e4a20826317bfee1abf863">authenticate()</a> function processes the initial reply, in which the server requested the client to authenticate itself. The previously rejected request is complemented, so it can be sent again. If authentication is not possible, for example, because no credentials are available, authenticate() will return false to indicate failure. </p>
</div></div><!-- contents -->

<div class="clear">&nbsp;</div>
<div id="footer">
	<div style="float:left;">Copyright &copy; 2003-2014 The Pt Development Team</div>
</div>
</div>
</body>
</html>
