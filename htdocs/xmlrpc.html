<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>XML-RPC Communication</title>
  <meta content="Pt Reference Manual" name="description">
  <meta content="The Pt Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body style="margin:0px;">
<div id="container">
<div id="top"> <!-- do not remove this div, it is closed by doxygen! -->
<div id="header">
    <table id="logo">
        <tr>
            <td>
                <a href="../index.html"><img src="platinum-logo.gif" border="0"/></a>
            </td>
            <td>
                <h3>The Power in your Hands</h3>
            </td>
        </tr>
    </table>
    <div class="search">
        <form action="http://search.freefind.com/find.html" method="get" accept-charset="utf-8" target="_self">
          <p style="margin: 0; padding-top:2px; padding-bottom:2px;"><b>Search Site:</b></p>
          <p style="margin: 0; padding:0;">
            <input type="hidden" name="si" value="43943317">
            <input type="hidden" name="pid" value="r">
            <input type="hidden" name="n" value="0">
            <input type="hidden" name="_charset_" value="">
            <input type="hidden" name="bcd" value="&#247;">
            <input style="background-color: #FFFFFF;
                          border: 1px solid #ffffff;
                          font-size: 12px;
                          width: 160px"
                   type="text" name="query" value="Search...">
          </p>
        </form>
    </div>
	<div class="header-menu">
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../index.html">About</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../features-modules.html">Features</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../docs.html">Documentation</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../downloads.html">Download</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../community.html">Community</a> </div>
	</div>
  </div>
<div class="header-submenu" style="padding-left: 146px;">  
    <div class="header-submenu-term"><img src="sub_left.png" width="4" height="20" /></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="../docs.html">Main</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="classes.html">Classes</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="namespaces.html">Namespaces</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="modules.html">Modules</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-term"><img src="sub_right.png" width="4" height="20" /></div>
</div>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">XML-RPC Communication </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The XML-RPC module (<a class="el" href="namespacePt_1_1XmlRpc.html" title="XML RPC services and clients. ">Pt::XmlRpc</a>) of the Pt framework provides a client API to call remote procedures and a server API to implement remote procedures. Blocking and non-blocking APIs exist in either case. The XML-RPC module builds on top of the HTTP module (<a class="el" href="namespacePt_1_1Http.html" title="HTTP server and client. ">Pt::Http</a>) and uses the HTTP client and server implementation thereof. Custom data-types can be used in XML-RPC procedures if they are serializable using Pt's serialization API.</p>
<h1><a class="anchor" id="xmlrpc_Service"></a>
XML-RPC Services</h1>
<p>The XML-RPC server side API is implemented as a service for Pt's HTTP server. Regular C++ functions or methods can be registered as XML-RPC remote procedures with a Pt::XmlRpc::ServiceDefinition. The service definition can then be used by the the <a class="el" href="classPt_1_1XmlRpc_1_1HttpService.html" title="HTTP service for XML-RPC. ">Pt::XmlRpc::HttpService</a>. The XML-RPC requests are processed and dispatched to the respective procedure by the service. Note, that the registered function or method will potentially be called from one of the HTTP server threads. The following example shows a typical XML-RPC service definition, where member functions are registered as XML-RPC procedures:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CalculatorService : <span class="keyword">public</span> Pt::XmlRpc::ServiceDefinition</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    CalculatorService()</div>
<div class="line">    {</div>
<div class="line">      registerProcedure(<span class="stringliteral">&quot;add&quot;</span>, *<span class="keyword">this</span>, &amp;CalculatorService::add);</div>
<div class="line">      registerProcedure(<span class="stringliteral">&quot;sub&quot;</span>, *<span class="keyword">this</span>, &amp;CalculatorService::sub);</div>
<div class="line">      registerProcedure(<span class="stringliteral">&quot;multiply&quot;</span>, *<span class="keyword">this</span>, &amp;CalculatorService::multiply);</div>
<div class="line">      registerProcedure(<span class="stringliteral">&quot;div&quot;</span>, *<span class="keyword">this</span>, &amp;CalculatorService::div);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">    { <span class="keywordflow">return</span> a+b; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> sub(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">    { <span class="keywordflow">return</span> a-b; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> multiply(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">    { <span class="keywordflow">return</span> a*b; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> div(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">    { <span class="keywordflow">return</span> a/b; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>One needs to inherit Pt::XmlRpc::ServiceDefinition and register the XML-RPC procedures in the constructor. The string passed to registerProcedure() is the name of the procedure and all XML-RPC requests with this 'methodName' XML tag will be dispatched to that method. The types used in the signatures of the service procedures have to be serializable (see <a class="el" href="serialization.html">Serialization</a>).</p>
<p>Once the XML-RPC service definition is implemented, it can be run within an instance of Pt's HTTP server. The incoming requests are mapped by the service name to the XML-RPC service and then processed and dispatched in the service to the registered procedures.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classPt_1_1System_1_1MainLoop.html">Pt::System::MainLoop</a> loop;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPt_1_1Net_1_1Endpoint.html">Pt::Net::Endpoint</a> ep(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7002);</div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1Server.html">Pt::Http::Server</a> server(loop, ep);</div>
<div class="line">    </div>
<div class="line">    CalculatorService service;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPt_1_1XmlRpc_1_1HttpService.html">Pt::XmlRpc::HttpService</a> httpService(service);</div>
<div class="line">    <a class="code" href="classPt_1_1Http_1_1MapUrl.html">Pt::Http::MapUrl</a> servlet(<span class="stringliteral">&quot;/calculator&quot;</span>, httpService);</div>
<div class="line">    server.<a class="code" href="classPt_1_1Http_1_1Server.html#ac4200942695db336eb7ddc5855032035">addServlet</a>(servlet);</div>
<div class="line"></div>
<div class="line">    loop.<a class="code" href="classPt_1_1System_1_1EventLoop.html#a13a43e6d814de94978c515cb084873b1">run</a>();</div>
<div class="line">};</div>
</div><!-- fragment --><p>The code above constructs a HTTP server instance and adds an XML-RPC service with the name '/calculator'. HTTP services are not directly added to a HTTP server, but as part of a servlet. The servlet of type <a class="el" href="classPt_1_1Http_1_1MapUrl.html" title="Maps requests to a service by URL. ">Pt::Http::MapUrl</a> instructs the server to route all requests for the URL '/calculator' to the CalculatorService. The server requires an event loop to run, in this case a program main loop.</p>
<h1><a class="anchor" id="xmlrpc_AsyncProcedures"></a>
Asynchronous XML-RPC Service Procedures</h1>
<p>Since the server has only a limited number of worker threads, the XML-RPC procedures should not block, for example to perform long I/O operations, otherwise the performance of the HTTP server will degrade. Instead, the asynchronous API allows using a <a class="el" href="classPt_1_1System_1_1EventLoop.html" title="Thread-safe event loop supporting I/O multiplexing and Timers. ">Pt::System::EventLoop</a> from within a XML-RPC procedure, as shown in the next example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AsyncEcho : <span class="keyword">public</span> Pt::XmlRpc::ActiveProcedure&lt;std::string, std::string&gt;</div>
<div class="line">                , <span class="keyword">public</span> <a class="code" href="classPt_1_1Connectable.html">Pt::Connectable</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:   </div>
<div class="line">    AsyncEcho(<a class="code" href="classPt_1_1XmlRpc_1_1Responder.html">Pt::XmlRpc::Responder</a>&amp; responder)</div>
<div class="line">    : Pt::XmlRpc::ActiveProcedure&lt;std::string, std::string&gt;(responder)</div>
<div class="line">    {</div>
<div class="line">      _timer.timeout() += Pt::slot(*<span class="keyword">this</span>, &amp;AsyncEcho::onTimeout);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onInvoke(System::EventLoop&amp; loop, <span class="keyword">const</span> std::string&amp; msg)</div>
<div class="line">    {</div>
<div class="line">      _r = msg;</div>
<div class="line"></div>
<div class="line">      _timer.setActive( loop );</div>
<div class="line">      _timer.start(1000);         </div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> std::string&amp; onResult()</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> _r;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> onTimeout()</div>
<div class="line">    {</div>
<div class="line">      _timer.stop();</div>
<div class="line">      _timer.detach();</div>
<div class="line">      this-&gt;setReady();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      std::string _r;</div>
<div class="line">      <a class="code" href="classPt_1_1System_1_1Timer.html">Pt::System::Timer</a> _timer;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The class AsyncEcho is an example of such an asynchronous call and it needs to derive from the Pt::XmlRpc::ActiveProcedure class template. The template parameters describe the signature of the XML-RPC procedure. The first parameter is the return type and the following parameters are the argument types. In this case, the XML-RPC procedure returns a std::string and takes one argument, also a std::string, when invoked. Two virtual functions have to be implemented. When the procedure is executed, onInvoke() will be called with arguments, as defined by the template parameters of ActiveProcedure. In the example, we use the event loop to start a timer. This is also the event loop of the server thread from which the procedure was invoked. When the timer runs out, ActiveProcedure::setReady() is called in the timer callback, to notify the XML-RPC service that the asynchronous call has finished. The service will then wake up and call onResult() to obtain the return value. The next example shows how the asynchronous service procedure is registered:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyService : <span class="keyword">public</span> Pt::XmlRpc::ServiceDefinition</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    MyService()</div>
<div class="line">    {</div>
<div class="line">      registerActiveProcedure(<span class="stringliteral">&quot;asyncEcho&quot;</span>, *<span class="keyword">this</span>, &amp;MyService::asyncEcho);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    AsyncEcho* asyncEcho(<a class="code" href="classPt_1_1XmlRpc_1_1Responder.html">Pt::XmlRpc::Responder</a>&amp; responder)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">new</span> AsyncEcho(proc);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>A member function is registered as an asynchronous XML-RPC procedure in the constructor of the service definition. But this deffers from the synchronous case, because the registered function is a factory for the actual asynchronous XML-RPC procedure.</p>
<h1><a class="anchor" id="xmlrpc_Client"></a>
XML-RPC Clients</h1>
<p>The XML-RPC client API is implemented as function objects using <a class="el" href="namespacePt.html" title="Core module. ">Pt</a>'s HTTP client. Calling a remote procedure with the blocking API looks similar to calling local functions, the non-blocking API uses <a class="el" href="namespacePt.html" title="Core module. ">Pt</a>'s signals and slots. The following example uses the blocking API to call a remote procedure, which expects two integer values as arguments and returns an interger value:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classPt_1_1Net_1_1Endpoint.html">Pt::Net::Endpoint</a> ep(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7002);</div>
<div class="line">    <a class="code" href="classPt_1_1XmlRpc_1_1HttpClient.html">Pt::XmlRpc::HttpClient</a> client(ep, <span class="stringliteral">&quot;/calculator&quot;</span>);</div>
<div class="line"></div>
<div class="line">    Pt::XmlRpc::RemoteProcedure&lt;int, int, int&gt; multiply(client, <span class="stringliteral">&quot;multiply&quot;</span>);</div>
<div class="line">    <span class="keywordtype">int</span> r = multiply(6, 7);</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; r &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(std::exception&amp; ex) <span class="comment">// might be Pt::XmlRpc::Fault</span></div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 1</div>
<div class="line">};</div>
</div><!-- fragment --><p>A HTTP client has to be constructed first, with the name of the XML-RPC service to be accessed. The HTTP client maintains a connection to the server and can be used for multiple remote procedure calls to the same XML-RPC service. A function object of type Pt::XmlRpc::RemoteProcedure is constructed then, where the template parameters describe the signature of the remote procedure. The first template parameter is the return value and the following ones are the arguments. The types used as the return value and the arguments have to be serializable (see <a class="el" href="serialization.html">Serialization</a>). The actual call might throw an exception, especially one of type <a class="el" href="classPt_1_1XmlRpc_1_1Fault.html" title="XML-RPC fault exception. ">Pt::XmlRpc::Fault</a>, if an error occurs in the XML-RPC layer.</p>
<p>A non-blocking API also exists, to make XML-RPC calls concurrently to other code. A remote procedure call is started using the same function objects like for the blocking calls and a signal gives notification when the remote call is ready to return a value. No additional threads are started to accomplish this, but I/O is dispatched through an event loop. Note that this is the preferred way of calling XML-RPC remote procedures, because even if no code is run concurrently, the calls can be cancelled.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> onResult(<span class="keyword">const</span> Pt::XmlRpc::Result&lt;int&gt;&amp; r)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; r.get() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::exception&amp; ex) <span class="comment">// might be Pt::XmlRpc::Fault</span></div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classPt_1_1System_1_1MainLoop.html">Pt::System::MainLoop</a> loop;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classPt_1_1Net_1_1Endpoint.html">Pt::Net::Endpoint</a> ep(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7002);</div>
<div class="line">    <a class="code" href="classPt_1_1XmlRpc_1_1HttpClient.html">Pt::XmlRpc::HttpClient</a> client(loop, ep, <span class="stringliteral">&quot;/calculator&quot;</span>);</div>
<div class="line"></div>
<div class="line">    Pt::XmlRpc::RemoteProcedure&lt;int, int, int&gt; multiply(client, <span class="stringliteral">&quot;multiply&quot;</span>);</div>
<div class="line">    multiply.finished += Pt::slot(&amp;onResult);</div>
<div class="line">    multiply.begin(6, 7);</div>
<div class="line"></div>
<div class="line">    loop.<a class="code" href="classPt_1_1System_1_1EventLoop.html#a13a43e6d814de94978c515cb084873b1">run</a>();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::exception&amp; ex)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The example above shows how the signal named 'finished' is connected to the slot 'onResult', which is called when the return value was received. The remote call is then only started calling begin() and all processing starts when the event loop is run. Once the remote procedure call returns, the result is passed to the slot in form of a Pt::XmlRpc::Result object. To retrieve the actual return value, get() must be called on this object, which might also throw an exception, if an error occured. The exception should be handled in the slot, if it is allowed to propagate, the event loop will be stopped and the program ends.</p>
<h1><a class="anchor" id="xmlrpc_Protocol"></a>
Protocol Details</h1>
<p>XML-RPC is a Remote Procedure Calling protocol that works over the network.</p>
<p>An XML-RPC message is an HTTP-POST request. The body of the request is in XML. A procedure executes on the server and the value it returns is also formatted in XML.</p>
<p>Procedure parameters can be scalars, numbers, strings, dates, etc.; and can also be complex record and list structures.</p>
<p><b>Firewalls:</b> The goal of this protocol is to lay a compatible foundation across different environments, no new power is provided beyond the capabilities of the CGI interface. Firewall software can watch for POSTs whose Content-Type is text/xml.</p>
<p><b>Discoverability:</b> We wanted a clean, extensible format that's very simple. It should be possible for an HTML coder to be able to look at a file containing an XML-RPC procedure call, understand what it's doing, and be able to modify it and have it work on the first or second try.</p>
<p><b>Easy to implement:</b> We also wanted it to be an easy to implement protocol that could quickly be adapted to run in other environments or on other operating systems.</p>
<h2><a class="anchor" id="xmlrpc_Request_Example"></a>
Request Example</h2>
<p>Here's an example of an XML-RPC request:</p>
<pre class="fragment">POST /calculator HTTP/1.0
User-Agent: Frontier/5.1.2 (WinNT)
Host: betty.userland.com
Content-Type: text/xml
Content-length: 181

&lt;?xml version="1.0"?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;multiply&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt; &lt;value&gt;&lt;int&gt;6&lt;/int&gt;&lt;/value&gt; &lt;/param&gt;
    &lt;param&gt; &lt;value&gt;&lt;int&gt;7&lt;/int&gt;&lt;/value&gt; &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</pre><p>The format of the URI in the first line of the header is not specified. For example, it could be empty, a single slash, if the server is only handling XML-RPC calls. However, if the server is handling a mix of incoming HTTP requests, we allow the URI to help route the request to the code that handles XML-RPC requests. In the example, the URI is /calculator, telling the server to route the request to the "calculator" service.</p>
<p>The payload is in XML, a single &lt;methodCall&gt; structure.</p>
<p>The &lt;methodCall&gt; must contain a &lt;methodName&gt; sub-item, a string, containing the name of the method to be called. The string may only contain identifier characters, upper and lower-case A-Z, the numeric characters, 0-9, underscore, dot, colon and slash. It's entirely up to the server to decide how to interpret the characters in a methodName.</p>
<p>For example, the methodName could be the name of a file containing a script that executes on an incoming request. It could be the name of a cell in a database table. Or it could be a path to a file contained within a hierarchy of folders and files.</p>
<p>If the procedure call has parameters, the &lt;methodCall&gt; must contain a &lt;params&gt; sub-item. The &lt;params&gt; sub-item can contain any number of &lt;param&gt;s, each of which has a &lt;value&gt;.</p>
<h2><a class="anchor" id="xmlrpc_Response_Example"></a>
Response Example</h2>
<p>Here's an example of an XML-RPC response:</p>
<pre class="fragment">HTTP/1.1 200 OK
Connection: close
Content-Length: 158
Content-Type: text/xml
Date: Fri, 17 Jul 2008 19:55:08 GMT
Server: UserLand Frontier/5.1.2-WinNT

&lt;?xml version="1.0"?&gt;
&lt;methodResponse&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;&lt;int&gt;42&lt;/int&gt;&lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodResponse&gt;
</pre><p>Unless there's a lower-level error, always return 200 OK.</p>
<p>The Content-Type is text/xml. Content-Length must be present and correct.</p>
<p>The body of the response is a single XML structure, a &lt;methodResponse&gt;, which can contain a single &lt;params&gt; which contains a single &lt;param&gt; which contains a single &lt;value&gt;.</p>
<h2><a class="anchor" id="xmlrpc_Fault_Example"></a>
Fault Example</h2>
<p>Here's an example of an XML-RPC fault response:</p>
<pre class="fragment">HTTP/1.1 200 OK
Connection: close
Content-Length: 426
Content-Type: text/xml
Date: Fri, 17 Jul 1998 19:55:02 GMT
Server: UserLand Frontier/5.1.2-WinNT

&lt;?xml version="1.0"?&gt;
&lt;methodResponse&gt;
  &lt;fault&gt;
    &lt;value&gt;
      &lt;struct&gt;
        &lt;member&gt;
          &lt;name&gt;faultCode&lt;/name&gt;
          &lt;value&gt;&lt;int&gt;4&lt;/int&gt;&lt;/value&gt;
        &lt;/member&gt;
        &lt;member&gt;
          &lt;name&gt;faultString&lt;/name&gt;
          &lt;value&gt;&lt;string&gt;Too many parameters.&lt;/string&gt;&lt;/value&gt;
        &lt;/member&gt;
      &lt;/struct&gt;
    &lt;/value&gt;
  &lt;/fault&gt;
&lt;/methodResponse&gt;
</pre><p>The &lt;methodResponse&gt; could also contain a &lt;fault&gt; which contains a &lt;value&gt; which is a &lt;struct&gt; containing two elements, one named &lt;faultCode&gt;, an &lt;int&gt; and one named &lt;faultString&gt;, a &lt;string&gt;.</p>
<p>A &lt;methodResponse&gt; can not contain both a &lt;fault&gt; and a &lt;params&gt;.</p>
<h1><a class="anchor" id="xmlrpc_Copyright"></a>
Copyright and Disclaimer</h1>
<p>This document contains parts of the original XML-RPC specification (<a href="http://www.xmlrpc.com">http://www.xmlrpc.com</a>), which is published under the following license:</p>
<p>Copyright 1998-2003 UserLand Software. All Rights Reserved.</p>
<p>This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and these paragraphs are included on all such copies and derivative works.</p>
<p>This document may not be modified in any way, such as by removing the copyright notice or references to UserLand or other organizations. Further, while these copyright restrictions apply to the written XML-RPC specification, no claim of ownership is made by UserLand to the protocol it describes. Any party may, for commercial or non-commercial purposes, implement this protocol without royalty or license fee to UserLand. The limited permissions granted herein are perpetual and will not be revoked by UserLand or its successors or assigns.</p>
<p>This document and the information contained herein is provided on an "AS IS" basis and USERLAND DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. </p>
</div></div><!-- contents -->

<div class="clear">&nbsp;</div>
<div id="footer">
	<div style="float:left;">Copyright &copy; 2003-2014 The Pt Development Team</div>
</div>
</div>
</body>
</html>
