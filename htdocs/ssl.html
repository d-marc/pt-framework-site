<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Secure Communication</title>
  <meta content="Pt Reference Manual" name="description">
  <meta content="The Pt Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body style="margin:0px;">
<div id="container">
<div id="top"> <!-- do not remove this div, it is closed by doxygen! -->
<div id="header">
    <table id="logo">
        <tr>
            <td>
                <a href="../index.html"><img src="platinum-logo.gif" border="0"/></a>
            </td>
            <td>
                <h3>The Power in your Hands</h3>
            </td>
        </tr>
    </table>
    <div class="search">
        <form action="http://search.freefind.com/find.html" method="get" accept-charset="utf-8" target="_self">
          <p style="margin: 0; padding-top:2px; padding-bottom:2px;"><b>Search Site:</b></p>
          <p style="margin: 0; padding:0;">
            <input type="hidden" name="si" value="43943317">
            <input type="hidden" name="pid" value="r">
            <input type="hidden" name="n" value="0">
            <input type="hidden" name="_charset_" value="">
            <input type="hidden" name="bcd" value="&#247;">
            <input style="background-color: #FFFFFF;
                          border: 1px solid #ffffff;
                          font-size: 12px;
                          width: 160px"
                   type="text" name="query" value="Search...">
          </p>
        </form>
    </div>
	<div class="header-menu">
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../index.html">About</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../features-modules.html">Features</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../docs.html">Documentation</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../downloads.html">Download</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../community.html">Community</a> </div>
	</div>
  </div>
<div class="header-submenu" style="padding-left: 146px;">  
    <div class="header-submenu-term"><img src="sub_left.png" width="4" height="20" /></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="../docs.html">Main</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="classes.html">Classes</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="namespaces.html">Namespaces</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="modules.html">Modules</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-term"><img src="sub_right.png" width="4" height="20" /></div>
</div>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Secure Communication </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ssl_CertStore"></a>
Certificate Management</h1>
<p>SSL/TLS communication usually requires certificates and keys, i.e. for server or client authentication and to build a list of trusted CA certificates to verify the peer. Certificates and keys encoded in PKCS12 format can be loaded into a <a class="el" href="classPt_1_1Ssl_1_1CertificateStore.html" title="A store for X509 certificates. ">Pt::Ssl::CertificateStore</a>, and then be used by the application.</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1Ssl_1_1CertificateStore.html">Pt::Ssl::CertificateStore</a> store;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* password = ...;</div>
<div class="line">std::ifstream ifs(<span class="stringliteral">&quot;certs.p12&quot;</span>);</div>
<div class="line">store.<a class="code" href="classPt_1_1Ssl_1_1CertificateStore.html#a8ae6f839090da6abdf382567483ca471">loadPkcs12</a>(ifs, password);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1Ssl_1_1CertificateStore_1_1ConstIterator.html">Pt::Ssl::CertificateStore::ConstIterator</a> it;</div>
<div class="line"><span class="keywordflow">for</span>(it = store.<a class="code" href="classPt_1_1Ssl_1_1CertificateStore.html#aeb8a08dab209e7d8bd94ea796e8055e7">begin</a>(); it != store.<a class="code" href="classPt_1_1Ssl_1_1CertificateStore.html#afd94c820b193c151ddbaae99185a24f4">end</a>(); ++it)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;subject: &quot;</span> &lt;&lt; it-&gt;<a class="code" href="classPt_1_1Ssl_1_1Certificate.html#a1b9ed8f3209f303d3c32d31d4f18c23c">subject</a>() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classPt_1_1Ssl_1_1Certificate.html">Pt::Ssl::Certificate</a>* cert = store.<a class="code" href="classPt_1_1Ssl_1_1CertificateStore.html#a3a72fe6a5f114b3f4185b7f5c6873186">findCertificate</a>(<span class="stringliteral">&quot;SGC Mainframe&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>( ! cert)</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;certifictate is missing&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The example shown above imports certificates and keys from a file, which is protected by a password. Certificates in the store can be inspected using the iterator API, or searched for by a subject string. Note, that a private key will be assoziated with its certificate and is not exposed or accessible by any API functions.</p>
<h1><a class="anchor" id="ssl_Context"></a>
Context Initialization</h1>
<p>Before any SSL/TLS connections can be established, a <a class="el" href="classPt_1_1Ssl_1_1Context.html" title="Context for SSL connections. ">Pt::Ssl::Context</a> has to be created, which allows to use the same set of certificates and settings for many connections.</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1Ssl_1_1Context.html">Pt::Ssl::Context</a> ctx(<a class="code" href="namespacePt_1_1Ssl.html#aac39b55be6469395f55ff0292ad8184ca4badde36beb0e803bac0c8545264fd13">Pt::Ssl::TLSv1</a>); <span class="comment">// SSLv2, SSLv3or2, SSLv3, TLSv1</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1Ssl_1_1Certificate.html">Pt::Ssl::Certificate</a>&amp; myCA = store.getCertifictate(<span class="stringliteral">&quot;My Certificate&quot;</span>);</div>
<div class="line">ctx.<a class="code" href="classPt_1_1Ssl_1_1Context.html#a669e161125c5f9d6b50effc9af6f6d06">setIdentity</a>(myCert);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classPt_1_1Ssl_1_1Certificate.html">Pt::Ssl::Certificate</a>&amp; myCA = store.getCertifictate(<span class="stringliteral">&quot;My CA&quot;</span>);</div>
<div class="line">ctx.<a class="code" href="classPt_1_1Ssl_1_1Context.html#a64c592bd18556c6921aa6c41204c83c6">addCACertificate</a>(myCA);</div>
<div class="line"></div>
<div class="line">ctx.<a class="code" href="classPt_1_1Ssl_1_1Context.html#aa86059ac2726d155770f7dc76ebe321d">setVerifyMode</a>(<a class="code" href="namespacePt_1_1Ssl.html#aec3fd496ba134cc896c9a62b4f37a281a8b8cef4284b42e10a4b39d3f3a5f07b1">Pt::Ssl::AlwaysVerify</a>); <span class="comment">// NoVerify, TryVerify, AlwaysVerify</span></div>
</div><!-- fragment --><p>A context can be created for a specific protocol type, e.g. TLSv1 which limits, the communication to that protocol. The method <a class="el" href="classPt_1_1Ssl_1_1Context.html#a669e161125c5f9d6b50effc9af6f6d06" title="Set the main certificate of this context. ">Pt::Ssl::Context::setIdentity()</a> sets the certificate presented to the peer. Since private keys are always assoziated with a certificate, when loaded into the CertificateStore, selecting a certificate means also selecting it's private key. The trusted CA certificates to verify the peer's identity can be added using the <a class="el" href="classPt_1_1Ssl_1_1Context.html#a64c592bd18556c6921aa6c41204c83c6" title="Add a certificate to the trusted CA certificates. ">Pt::Ssl::Context::addCACertificate()</a> method. <a class="el" href="classPt_1_1Ssl_1_1Context.html#aa86059ac2726d155770f7dc76ebe321d" title="Sets the current validation mode. ">Pt::Ssl::Context::setVerifyMode()</a> indicates whether the peer is required to authenticate itself during the handshake.</p>
<h1><a class="anchor" id="ssl_Connection"></a>
Opening a Connection</h1>
<p>A secure connection can be established using a <a class="el" href="classPt_1_1Ssl_1_1IOStream.html" title="SSL stream. ">Pt::Ssl::IOStream</a> or a <a class="el" href="classPt_1_1Ssl_1_1StreamBuffer.html" title="SSL stream buffer. ">Pt::Ssl::StreamBuffer</a>. These classes are built on top of the iostreams library of the C++ standard and implement a std::iostream or std::streambuf, respectively. They operate on another underlying std::iostream, from which data is read and decrypted or encrypted and written to. This allows the Pt-Ssl module to be independent of any socket or transport layer.</p>
<p>Besides an underlying std::iostream for the data transport to the peer, a <a class="el" href="classPt_1_1Ssl_1_1Context.html" title="Context for SSL connections. ">Pt::Ssl::Context</a> is required to open a <a class="el" href="classPt_1_1Ssl_1_1IOStream.html" title="SSL stream. ">Pt::Ssl::IOStream</a>. The settings and certificates from this context will be used for the connection. Furthermore, the stream can be opened as a client stream or server stream, indicated by the <a class="el" href="namespacePt_1_1Ssl.html#a3a70f8b621474c9885f80fe709e2dca2" title="Open mode for ssl I/O. ">Pt::Ssl::OpenMode</a>, being either <a class="el" href="namespacePt_1_1Ssl.html#a3a70f8b621474c9885f80fe709e2dca2aee552f3150bddbf101d3541c3218010e" title="Connect to server. ">Pt::Ssl::Connect</a> or <a class="el" href="namespacePt_1_1Ssl.html#a3a70f8b621474c9885f80fe709e2dca2a2e9639ddb75a9a4f7c0402e691fae0fa" title="Accept client. ">Pt::Ssl::Accept</a>.</p>
<div class="fragment"><div class="line">std::iostream&amp; ios = ...;</div>
<div class="line"></div>
<div class="line"><span class="comment">// constructs a ssl client stream</span></div>
<div class="line"><a class="code" href="classPt_1_1Ssl_1_1IOStream.html">Pt::Ssl::IOStream</a> clientSsl(ctx, ios, <a class="code" href="namespacePt_1_1Ssl.html#a3a70f8b621474c9885f80fe709e2dca2aee552f3150bddbf101d3541c3218010e">Pt::Ssl::Connect</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// constructs a ssl server stream</span></div>
<div class="line"><a class="code" href="classPt_1_1Ssl_1_1IOStream.html">Pt::Ssl::IOStream</a> serverSsl(ctx, ios, <a class="code" href="namespacePt_1_1Ssl.html#a3a70f8b621474c9885f80fe709e2dca2a2e9639ddb75a9a4f7c0402e691fae0fa">Pt::Ssl::Accept</a>);</div>
</div><!-- fragment --><p>The <a class="el" href="namespacePt_1_1Ssl.html#a3a70f8b621474c9885f80fe709e2dca2" title="Open mode for ssl I/O. ">Pt::Ssl::OpenMode</a> decides whether a client handshake or a server handshake will be carried out. After a <a class="el" href="classPt_1_1Ssl_1_1IOStream.html" title="SSL stream. ">Pt::Ssl::IOStream</a> is created and opened, the handshake can be peformed with the methods <a class="el" href="classPt_1_1Ssl_1_1IOStream.html#a4756a847468fb69d6c6adf4ed82d6a2f" title="Reads handshake message from the underlying stream. ">Pt::Ssl::IOStream::readHandshake()</a> and <a class="el" href="classPt_1_1Ssl_1_1IOStream.html#a67e179596ba025c1f325afab4e67684f" title="Writes a handshake message to the underlying stream. ">Pt::Ssl::IOStream::writeHandshake()</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1Ssl_1_1IOStream.html">Pt::Ssl::IOStream</a>&amp; ssl = ...;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span>( ! ssl.<a class="code" href="classPt_1_1Ssl_1_1IOStream.html#a180fa55a4bf36580963bed9e3e09c227">isConnected</a>() )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> wantRead = ssl.<a class="code" href="classPt_1_1Ssl_1_1IOStream.html#a4756a847468fb69d6c6adf4ed82d6a2f">readHandshake</a>();</div>
<div class="line">    <span class="keywordflow">if</span>(wantRead)</div>
<div class="line">    {</div>
<div class="line">        [ make more data available in the underlying stream ]</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line">                </div>
<div class="line">    <span class="keywordtype">bool</span> wantWrite = ssl.<a class="code" href="classPt_1_1Ssl_1_1IOStream.html#a67e179596ba025c1f325afab4e67684f">writeHandshake</a>();</div>
<div class="line">    <span class="keywordflow">if</span>( wantWrite )</div>
<div class="line">    {</div>
<div class="line">        [ flush the underlying stream ]</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Essentially, readHandshake() and writeHandshake() have to be called repeatedly, until the <a class="el" href="classPt_1_1Ssl_1_1IOStream.html" title="SSL stream. ">Pt::Ssl::IOStream</a> is connected. If readHandshake() returns true, more data has to be read, but not enough data was available in the underlying stream. Only as many bytes will be consumed from the underlying stream as std::streambuf::in_avail() indicates. This allows non-blocking communication, since readHandshake() can be called again when more data becomes available. If readHandshake() returns false, no more data needs to be read. Then writeHandshake() is called, which returns true if data was written to the underlying stream that needs to be transfered. In the non-blocking case, we can call writeHandshake() again once the data was written.</p>
<h1><a class="anchor" id="ssl_ReadWrite"></a>
Reading and Writing Data</h1>
<p>Once the connection is open, data can be encrypted and decrypted. This can be achieved using the blocking I/O API inherited from std::iostream or the non-blocking API offered by <a class="el" href="classPt_1_1Ssl_1_1IOStream.html" title="SSL stream. ">Pt::Ssl::IOStream</a> and <a class="el" href="classPt_1_1Ssl_1_1StreamBuffer.html" title="SSL stream buffer. ">Pt::Ssl::StreamBuffer</a>. In the non-blocking case, available data can be imported from the underlying stream.</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1Ssl_1_1IOStream.html">Pt::Ssl::IOStream</a>&amp; ssl = ...;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(;;)</div>
<div class="line">{</div>
<div class="line">    ssl.<a class="code" href="classPt_1_1Ssl_1_1IOStream.html#a893fad161e0bcb173591cae663514dbf">import</a>();</div>
<div class="line"></div>
<div class="line">    std::streamsize avail = ssl.<a class="code" href="classPt_1_1Ssl_1_1IOStream.html#ac8faaf2644d39b5ada114ab79fc78ea3">sslBuffer</a>().in_avail();</div>
<div class="line">    <span class="keywordflow">if</span>(avail &lt;= 0)</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">char</span> buf[255];</div>
<div class="line">        std::streamsize n = ssl.readsome( buf, <span class="keyword">sizeof</span>(buf) );</div>
<div class="line">        std::cout.write(buf, n);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">while</span>( ssl.<a class="code" href="classPt_1_1Ssl_1_1IOStream.html#ac8faaf2644d39b5ada114ab79fc78ea3">sslBuffer</a>().in_avail() &gt; 0 );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span>( ssl.<a class="code" href="classPt_1_1Ssl_1_1IOStream.html#aeef4956a1d664e5fd10ede9e9c11e247">isShutdown</a>() )</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;received shutdown alert&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The method <a class="el" href="classPt_1_1Ssl_1_1IOStream.html#a893fad161e0bcb173591cae663514dbf" title="Reads user message from the underlying stream. ">Pt::Ssl::IOStream::import()</a> does not read more data from the underlying std::iostream than in_avail() of it's std::streambuf indicates. It might decrypt only a part of the available data, if not all bytes could be imported into the buffer of the <a class="el" href="classPt_1_1Ssl_1_1IOStream.html" title="SSL stream. ">Pt::Ssl::IOStream</a>. To drain the underlying stream, import() should be called in a loop. After calling import(), decrypted data may be available and can be processed. It is also possible that a shutdown alert was received, which can be checked for with isShutdown(). Premature EOF has to be handled by the code that maintains the underlying std::iostream. When data is written to a <a class="el" href="classPt_1_1Ssl_1_1IOStream.html" title="SSL stream. ">Pt::Ssl::IOStream</a>, it is encrypted and eventually written to the underying std::iostream.</p>
<div class="fragment"><div class="line"><a class="code" href="classPt_1_1Ssl_1_1IOStream.html">Pt::Ssl::IOStream</a>&amp; ssl = ...;</div>
<div class="line"></div>
<div class="line">ssl &lt;&lt; <span class="stringliteral">&quot;pi is: &quot;</span> &lt;&lt; 3.1415 ;</div>
<div class="line">ssl.flush();</div>
</div><!-- fragment --><p>To make sure the encrypted data is completely written to the underlying stream, the <a class="el" href="classPt_1_1Ssl_1_1IOStream.html" title="SSL stream. ">Pt::Ssl::IOStream</a> should be flushed. If not flushed, a part or all of the data might reside in the output buffer area. The API inherited from std::ostream can be used to flush the stream, that is std::ostream::flush or the stream manipulators std::flush and std::endl. The code that provided the underlying stream then has to transfer the data to the peer. This works well with the <a class="el" href="classPt_1_1System_1_1IOStream.html" title="Input/Output stream for I/O devices. ">Pt::System::IOStream</a> as the underlying stream, which only buffers the data written to it. When a limit is reached, the data can be written asynchronously making room for more encrypted data.</p>
<h1><a class="anchor" id="ssl_Shutdown"></a>
Connection Shutdown</h1>
<p>A connection shutdown alert can be initiated by either peer and the method <a class="el" href="classPt_1_1Ssl_1_1IOStream.html#aeef4956a1d664e5fd10ede9e9c11e247" title="Returns true if the shutown notify has to be completed. ">Pt::Ssl::IOStream::isShutdown()</a> indicates that the connection is shutting down. If a shutdown alert is received during a read operation, <a class="el" href="classPt_1_1Ssl_1_1IOStream.html#aec1255304305c9d8eff8571c0fd87b80" title="Shutdown the SSL connection. ">Pt::Ssl::IOStream::shutdown()</a> will write the shutdown acknowledge to the underlying stream and return true. This data still needs to be sent to the peer then, but from the perspective of the <a class="el" href="classPt_1_1Ssl_1_1IOStream.html" title="SSL stream. ">Pt::Ssl::IOStream</a>, the connection is considered closed and isShutdown() no longer returns true. If shutdown() is called to initiate a shutdown, the shutdown alert is written to the underlying std::iostream and needs to be sent to the peer. When the shutdown acknowledgement becomes available in the underlying std::iostream, shutdown() must be called again to consume it, which will return true if the shutdown acknowledge is complete. </p>
</div></div><!-- contents -->

<div class="clear">&nbsp;</div>
<div id="footer">
	<div style="float:left;">Copyright &copy; 2003-2014 The Pt Development Team</div>
</div>
</div>
</body>
</html>
