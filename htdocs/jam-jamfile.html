<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Using the Jambase</title>
  <meta content="Pt Reference Manual" name="description">
  <meta content="The Pt Development Team" name="author">
  <link rel="stylesheet" href="doxygen.css" type="text/css">
</head>
<body style="margin:0px;">
<div id="container">
<div id="top"> <!-- do not remove this div, it is closed by doxygen! -->
<div id="header">
    <table id="logo">
        <tr>
            <td>
                <a href="../index.html"><img src="platinum-logo.gif" border="0"/></a>
            </td>
            <td>
                <h3>The Power in your Hands</h3>
            </td>
        </tr>
    </table>
    <div class="search">
        <form action="http://search.freefind.com/find.html" method="get" accept-charset="utf-8" target="_self">
          <p style="margin: 0; padding-top:2px; padding-bottom:2px;"><b>Search Site:</b></p>
          <p style="margin: 0; padding:0;">
            <input type="hidden" name="si" value="43943317">
            <input type="hidden" name="pid" value="r">
            <input type="hidden" name="n" value="0">
            <input type="hidden" name="_charset_" value="">
            <input type="hidden" name="bcd" value="&#247;">
            <input style="background-color: #FFFFFF;
                          border: 1px solid #ffffff;
                          font-size: 12px;
                          width: 160px"
                   type="text" name="query" value="Search...">
          </p>
        </form>
    </div>
	<div class="header-menu">
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../index.html">About</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../features-modules.html">Features</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../docs.html">Documentation</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../downloads.html">Download</a> </div>
		<div class="header-menu-entry-sep"></div>
		<div class="header-menu-entry"> 
            <a id="header-menu-link" href="../community.html">Community</a> </div>
	</div>
  </div>
<div class="header-submenu" style="padding-left: 146px;">  
    <div class="header-submenu-term"><img src="sub_left.png" width="4" height="20" /></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="../docs.html">Main</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="classes.html">Classes</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="namespaces.html">Namespaces</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-entry">
        <a id="header-submenu-link" href="modules.html">Modules</a></div>
	<div class="header-submenu-entry-sep"></div>
    <div class="header-submenu-term"><img src="sub_right.png" width="4" height="20" /></div>
</div>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Using the Jambase </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> 

<A NAME="jam_overview"><H1>Overview</H1></A>
<P>
    This document describes how to use the various Jambase rules from a 
    functional point of view. You can see the summary of available Jambase
    rules in the <a href="jam-jambase.html">Jambase Reference</A>. The
    detailed specifications for any Jambase rule can be found by reading the
    rule definition itself in the Jambase.
</P>

<A NAME="jam_building"><H1>Build Configuration</H1></A>
<P>
    The build configuration rules can only be used in the Jamconfigure script
    and perform the necessary tests to determine whether all dependencies
    required for the build are present. When the Jamconfigure script is run
    in the build configuration step, the Jamrules file is generated. This file
    is loaded at the beginning of the build step.
</P>

<H4> CheckBuildC, CheckBuildC++ Rules </H4>
<P>
    Once the toolset has been configured with the ConfigureC or the 
    ConfigureC++ rule, the rules CheckBuildC and CheckBuildC++ can be used 
    to build small test programs to find out if headers and libraries are 
    available.
</P>

<PRE>
    WITH_DL = [ CheckBuildC++ "#include <dlfcn.h>"
                              "int main() { dlopen(0,0); return 0; }"
                             : ""
                             : -ldl ] ; 
    if ! 
    {
        Exit "dlopen not available" ;
    }
</PRE>

<P>
    This uses the C++ toolset to compile a small program calling a function
    of the dl library. The program is linked with the linker flag -ldl. The
    third argument passed to CheckBuildC++ is empty, but additional compiler
    flags could be passed here. An optional fifth argument allows to pass
    linker paths to the build command. The rule will return nothing if the 
    program can not be built and a boolean-like value on success. The command
    will be logged in the file Jamrules.log.
</P>

<H4> Configure Rule </H4>
<P>
    The Configure rule can be used to make the result of a test available to
    the following build steps.
</P>
<PRE>
    WITH_FOO = ;
    if --with-foo in &#36;(ARGS)
    {
        WITH_FOO = yes ;
    }

    Configure WITH_FOO ; 
</PRE>

<P>
    This tests if the command line option "--with-foo" was set and if so,
    the jam variable named WITH_FOO is stored in the build configuration
    result file. Note, that empty variables are not stored, so later in the
    Jamfiles it can simply be tested if WITH_FOO is set or not.
</P>

<H4> ConfigureCc, ConfigureC++ Rules </H4>
<P>
    The ConfigureCc and ConfigureC++ rules can be used to configure the 
    toolset, so that C or C++ programs can be built with the build rules 
    like Main, Library and SharedLibrary. They do not require any arguments
    and have to be invoked before any other tests are done that require 
    the toolsets to be functional.
</P>
<PRE>
    ConfigureCc ;
    ConfigureC++ ;
</PRE>
<P>
    Most, if not all Jamconfigure scripts call one or both rules at the
    beginning. All tests will be logged in the file Jamrules.log.
</P>

<H4> EchoOption </H4>
<P>
    This rule formats and prints the value and description of a configured 
    value. It has the purpose to indicate progress during the configuration
    step.
</P>
<PRE>
    EchoOption --with-foo : "Enable foo module" : $(WITH_FOO:E="no") ;
</PRE>

<P>
    The first argument is the option itself, the second one the description
    and the third one the value configured for the option. The third
    argument is optional and if left away, the first argument will be taken
    as the name of the jam variable that holds the value:
</P>

<PRE>
    EchoOption MY_INSTALL_BINDIR : "Program installation directory" ;
</PRE>

<P>
    If this form is used, it will be indicated that the MY_INSTALL_BINDIR
    variable can be overridden with the -s command line switch, in this case
    something like -sMY_INSTALL_BINDIR=/some/dir.
</P>

<H4> TryCommand </H4>
<P>
    The TryCommand rule takes one argument and that is a shell command to
    execute. It can be used to check if a required tool is in the path:
</P>
<PRE>
    if [ TryCommand "ls" ]
    {
        Echo The ls command is available ;
    }
    else
    {
        Echo The ls command is not available ;
    }
</PRE>
    The rule returns nothing if the return code of the shell command indicates
    failure. All output of the command will be written to the logfile 
    config.log. This is the most basic form to perform tests, but usually one 
    of the more high-level configuration rules will be used.
<P>

<A NAME="jam_building"><H1>Building Executables and Libraries</H1></A>
<P>
    The rules to build targets can only be used in the Jamfiles and the
    Jamrules script. All build options that were configured are available
    in the build step. Some rules like Main, Library and SharedLibray
    can only work if the toolset has been configured previously.
</P>

<A NAME="jam_subdirs"><H3>Handling Directory Trees</H3></A>

<P>
    The SubDir* rules are used to define source code directory hierarchies.
    With SubDir and SubInclude, you can use <b>jam</b> to build software 
    from source files and Jamfiles spread across many directories, as is 
    typical for large projects. The SubDir* rules unify an entire source 
    code tree so that <b>jam</b> can read in all the Jamfiles in one pass 
    and compute dependencies across the entire project.

</P>
    To use the SubDir* rules, you must:
<P>
<OL>
    <LI> Preface the Jamfile in each directory with an invocation 
       of the SubDir rule.
<P>
    <LI> Optionally, set an environment variable pointing
        to the root directory of the source tree. The
        variable's name is left up to you, but in these
        examples, we use TOP.
</OL>

<P>
<H4>
   SubDir Rule
</H4>
<P>
       The  SubDir  rule  must  be  invoked before any rules that
       refer to the contents of the directory - it is best to put
       it at the top of each Jamfile.  For example:
<PRE>
    # Jamfile in &#36;(TOP)/src/util directory.

    SubDir TOP src util ;

    Main myprog : main.c util.c ;                   
    LinkLibraries myprog : libtree ;     
    Library libtree : treemake.c treetrav.c ;    
</PRE>
       This  compiles  four  files  in  &#36;(TOP)/src/util, archives
       two of the objects into libtree, and links  the  whole
       thing into myprog. Outputs are placed in the &#36;(TOP)/src/util
       directory. Two things are happening behind the scenes:
    <UL>

    <LI>The SubDir rule causes <b>jam</b> to read in the &#36;(TOP)/Jamrules
        file. (The Jamrules file can alternately be named by the variable  
        &#36;(xxxRULES), where xxx is the name of the root variable, e.g., 
        &#36;(TOPRULES)).
        <P>
        Jamrules is only read in once, at the first SubDir invocation.
        <P>
    <LI>
       The SubDir rule initializes a set of variables
       that are used by Main and other rules to 
       uniquely identify the source files in this
       directory and assign locations to the targets
       built from files in this directory.
       <P>
       When you have set a root variable, e.g., &#36;(TOP),
       SubDir constructs path names rooted with &#36;(TOP),
       e.g., &#36;(TOP)/src/util.
       Otherwise, SubDir constructs relative pathnames
       to the root directory, computed from the number
       of arguments to the first SubDir rule, e.g.,
       ../../src/util. In either case, the SubDir
       rule constructs the path names that locate source
       files.
       You'll see how this is useful later.
    <P>

    </UL>

<P>
    The SubDir rule takes  as  its  first  argument  the  root
    variable's  name  and  takes  as  subsequent arguments the
    directory names leading from the root to the directory  of
    the  current Jamfile.  Note that the name of the subdirectory 
    is given as individual  elements:   the  SubDir  rule
    does not use system-specific directory name syntax.
<P>
<P>
<H4>
   SubInclude Rule
</H4>
    The SubInclude rule is used in a Jamfile to cause another
    Jamfile to be read in.
       Its arguments are in  the  same  format  as
       SubDir's.
<P>
       The  recommended  practice is only to include one level of
       subdirectories at a time, and let the Jamfile in each subdirectory  
       include  its own subdirectories.  This allows a
       user to sit in any arbitrary directory of the source  tree
       and build that subtree.  For example:

<PRE>
       # This is &#36;(TOP)/Jamfile, top level Jamfile for mondo project.

       SubInclude TOP src ;
       SubInclude TOP man ;
       SubInclude TOP misc ;
       SubInclude TOP util ;
</PRE>
       If  a directory has both subdirectories of its own as well
       as files that need building,  the  SubIncludes  should  be
       either before the SubDir rule or be at the end of the Jamfile 
       - not between the SubDir and other rule  invocations.
       For example:
<PRE>
    # This is &#36;(TOP)/src/Jamfile:

    SubDir TOP src ;

    Main mondo : mondo.c ;
    LinkLibraries mondo : libmisc libutil ;
    
    SubInclude TOP src misc ;
    SubInclude TOP src util ;
</PRE>
<P>
    (<b>jam</b> processes all the Jamfiles it reads as if
    it were reading one single, large Jamfile. 
    Build rules like Main and LinkLibraries rely on the
    preceding SubDir rule to set up source file and
    output file locations, and SubIncludes rules read in
    Jamfiles that contain SubDir rules. So if you put
    a SubIncludes rule between a SubDir and a Main
    rule, <b>jam</b> will try to find the source files
    for the Main rule in the wrong directory.)

<P>
<H4>
   Variables Used to Handle Directory Trees
</H4>
       The  following  variables are set by the SubDir rule
       and used by the Jambase rules that define file targets:
<P>
<CENTER>
<TABLE>
<TR><TD VALIGN=TOP>
              SEARCH_SOURCE
          <TD><TD>The SubDir targets (e.g., "TOP src util")
          are used to construct a pathname (e.g., &#36;(TOP)/src/util),
          and that pathname is assigned to &#36;(SEARCH_SOURCE).
          Rules like Main and Library use &#36;(SEARCH_SOURCE)
          to set search paths on source files.
<TR><TD VALIGN=TOP>
              LOCATE_SOURCE
          <TD><TD>Initialized by the SubDir rule to the same
          value as &#36;(SEARCH_SOURCE), unless ALL_LOCATE_TARGET
          is set.
          &#36;(LOCATE_SOURCE) is used by rules that build
          generated source files (e.g., Yacc and Lex) to
          set location of output files.
          Thus the default location of built source files
          is the directory of the Jamfile that defines them.

<TR><TD VALIGN=TOP>
              LOCATE_TARGET
          <TD><TD>Initalized by the SubDir rule to the same
          value as &#36;(SEARCH_SOURCE), unless ALL_LOCATE_TARGET
          is set.
          &#36;(LOCATE_TARGET) is used by rules that build
          binary objects (e.g., Main and Library) to
          set location of output files.
          Thus the default location of built binaray files
          is the directory of the Jamfile that defines them.
<TR><TD VALIGN=TOP>
              ALL_LOCATE_TARGET
          <TD><TD>
          If &#36;(ALL_LOCATE_TARGET) is set, LOCATE_SOURCE
          and and LOCATE_TARGET are set to  &#36;(ALL_LOCATE_TARGET)
          instead of to &#36;(SEARCH_SOURCE). This can be used to
          direct built files to be written to a location outside
          of the source tree, and enables building from read-only
          source trees.
<TR><TD VALIGN=TOP>
              SOURCE_GRIST
          <TD><TD>The SubDir targets are formed into a string
          like "src!util" and that string is assigned to 
          SOURCE_GRIST. Rules that define file targets
          use &#36;(SOURCE_GRIST) to set the "grist" attribute
          on targets. This is used to assure uniqueness 
          of target identifiers where filenames themselves
          are not unique.
          For example, the target identifiers of 
          &#36;(TOP)/src/client/main.c and &#36;(TOP)/src/server/main.c
          would be &lt;src!client&gt;main.c and &lt;src!server&gt;main.c.

</TABLE>
</CENTER>
<P>
       The &#36;(LOCATE_TARGET) and  &#36;(SEARCH_SOURCE)  variables are used
       extensively by rules in Jambase: most rules that  generate
       targets  (like  Main,  Object,  etc.)  set &#36;(LOCATE) to
       &#36;(LOCATE_TARGET) for the targets they generate, and  rules
       that  use  sources  (most all of them) set &#36;(SEARCH) to be
       &#36;(SEARCH_SOURCE) for the sources they use.
<P>
       &#36;(LOCATE) and &#36;(SEARCH) are better  explained  in
       <A HREF="jam-usage.html">Basic Usage</A>
       but in brief they tell <B>jam</B> where to create new targets and
       where to find existing ones, respectively.
<P>
       Note that you can reset these variables
       after SubDir sets them. For example, this Jamfile builds
       a program called gensrc, then runs it to create a source file
       called new.c: 
       <PRE>

       SubDir TOP src util ;
       Main gensrc : gensrc.c ;
       LOCATE_SOURCE = &#36;(NEWSRC) ;
       GenFile new.c : gensrc ;
       </PRE>
       By default, new.c would be written into the
       &#36;(TOP)/src/util directory, but resetting LOCATE_SOURCE causes
       it to be written to the &#36;(NEWSRC) directory. (&#36;(NEWSRC) is assumed
       to have been set elsewhere, e.g., in Jamrules.)
<P>
<H4>
   VMS Notes
</H4>
       On VMS, the logical name table is not imported as  is  the
       environment on UNIX.  To use the SubDir and related rules,
       you must set the value of the variable that names the root
       directory.  For example:
<PRE>
              TOP = USR_DISK:[JONES.SRC] ;

              SubInclude TOP util ;
</PRE>
       The variable must have a value that looks like a directory
       or device.  If you choose, you can use a  concealed  logical.  
       For example:

<PRE>
              TOP = TOP: ;

              SubInclude TOP util ;
</PRE>
       The  :  at  the  end of TOP makes the value of &#36;(TOP) look
       like a device name, which jam respects as a directory name
       and  will  use when trying to access files.  TOP must then
       be defined from DCL:
<PRE>
              &#36; define/job/translation=concealed TOP DK100:[USERS.JONES.SRC.]
</PRE>
       Note three things: the concealed  translation  allows  the
       logical  to  be  used as a device name; the device name in
       the logical (here DK100) cannot itself be concealed  logical  
       (VMS  rules, man); and the directory component of the
       definition must end in a period (more VMS rules).
<P>

<H4> Main Rule </H4>

    The Main rule compiles source files and links the  resulting 
    objects into an executable.  For example:

    <PRE>
        Main myprog : main.c util.c ;
    </PRE>

    This  compiles  main.c  and  util.c  and  links main.o and
    util.o into myprog. The object files and resulting 
    executable are named appropriately for the platform.
    <P>
    
    Main uses the Objects rule to compile source targets. 
    <P>

<H4> Library Rule </H4>

    The Library  rule  compiles  source  files,  archives  the
    resulting  object  files  into a static library, and then deletes
    the object files.  For example:

    <PRE>
        Library libstring : strcmp.c strcpy.c strlen.c ;
        Library libtree : treemake.c treetrav.c ;
    </PRE>

    This compiles five source files,  archives  three  of  the
    object  files into libstring and the other two into libtree.  
    Actual library filenames are formed with the &#36;(SUFLIB) suffix.
    Once the objects are safely in the libraries, the
    objects are deleted.
    <P>

    Library uses the Objects rule to compile source files.
    <P>

<H4> SharedLibrary </H4>

    The rule 'SharedLibrary' compiles source files and links the resulting
    objects into a shared library. For example:

    <PRE>
        SharedLibrary example : example.c util.c ;
    </PRE>

    This  compiles  example.c  and  util.c  and  links example.o and
    util.o into example. The object files and resulting
    executable are named appropriately for the platform.
    Main uses the Objects rule to compile source targets.
    <P>

    Normally, SharedLibrary uses &#36;(SUFLIB) and &#36;(SUFDLL) to determine the
    prefix/suffix on the filename of the built target. Under windows the
    resulting library will be called example.dll and a import library
    called example.lib will be created. Under unix, one shared library
    called libexample.so will be created. To override it,  you can supply
    a prefix/suffix explicity.
    <P>

<H4> LinkLibraries Rule </H4>

    To link executables or shared libraries with built static libraries,
    use the LinkLibraries rule. For example:

    <PRE>
        Library tree : tree.c ;
        Library string : string.c ;

        Main myprog : main.c util.c ;
        LinkLibraries myprog : tree ;

        SharedLibrary mydll : dll.c stuff.c ;
        LinkLibraries mydll : string tree ;
    </PRE>

    The LinkLibraries rule  does  two  things:  it  makes  the
    libraries dependencies of the executable, so that they get
    built first; and it makes the libraries  show  up  on  the
    command  line  that links the executable.  The ordering of
    the lines above is important, because the preceeding Main
    or SharedLibrary Rule define its target.
    <P>

    You  can  put multiple libraries on a single invocation of
    the LinkLibraries rule, or you can provide them in multiple
    invocations. In both cases, the libraries appear on
    the link command line in the  order  in  which  they  were
    encountered.
    <P>

<H4> LinkSharedLibraries Rule </H4>

    To link executables or shared libraries with built shared libraries,
    use the LinkSharedLibraries rule.  For example:

    <PRE>
        SharedLibrary mydll : dll.c stuff.c ;

        Main myprog : main.c util.c ;
        LinkSharedLibraries myprog : mydll ;
    </PRE>

    The LinkSharedLibraries rule  does  two  things:  it  makes  the
    libraries dependencies of the executable, so that they get
    built first; and it makes the libraries  show  up  on  the
    command  line  that links the executable. The ordering of
    the lines above is important, because the preceeding Main
    or SharedLibrary Rules type its target.
    <P>

    You  can  put multiple libraries on a single invocation of
    the LinkSharedLibraries rule, or you can provide them in multiple
    invocations. In both cases, the libraries appear on
    the link command line in the  order  in  which  they  were
    encountered. E. g.:

    <PRE>
        LinkSharedLibraries myprog : dll1 dll2 ;
    </PRE>
    <P>

<H4> LinkLibs Rule </H4>
    The LinkLibs rule adds library linker flags for a target such as an 
    executable of shared library. The rule does so by setting the LINKLIBS
    variable on the targets specified in the first argument. The following 
    example uses the library linker flags contained in MYPROG_LINKLIBS when
    myprog is linked:

    <PRE>
        Main myprog : main.c util.c ;
        LinkLibs myprog :  ;
    </PRE>
    <P>

    This rule is useful for linker flags that specify which libraries should
    be linked, like the -lxxx flags for most unix toolsets, because these
    flags must be placed at a special position in the linker command line.
    Use the LinkFlags rule for other linker flags.
    <P>

<H4> LinkFlags Rule </H4>

    The LinkFlags adds specific linker flag for a target such as an executable
    or shared library. For example:

    <PRE>
        Main myprog : main.c util.c ;
        LinkFlags myprog : &#36;(FLAGS) ;

        SharedLibrary mydll : dll.c stuff.c ;
        LinkFlags mydll : &#36;(FLAGS) ;
    </PRE>

    This  adds the linker flags contained in &#36;(FLAGS) to the command line
    that links the targets myprog or mydll.
    Do not use this rule for linker flags that specify which libraries should
    be linked, like the -lxxx flags required by most unix toolsets. Use the
    LinkLibs rule for this, because these library linker flags have to be
    placed at a special position in the linker command line.
    <P>

<H4> Variables Used in Building Executables and Libraries </H4>
<CENTER>
<TABLE>
<TR><TD>
              AR           
          <TD><TD>Archive command, used for Library targets.
<TR><TD>
              SUFEXE         
          <TD>*<TD>Suffix on filenames of executables referenced
        by Main and LinkLibraries.
<TR><TD>
              SUFDLL         
          <TD>*<TD>Suffix on filenames of shared libraries referenced
        by SharedLibrary and LinkSharedLibraries.
<TR><TD>
              LINK           
          <TD><TD>Link command, used for Main targets.

<TR><TD>
              LINKFLAGS       
          <TD><TD>Linker flags.
<TR><TD>
              LINKLIBS        
          <TD><TD>Link libraries that aren't dependencies. (See note
        below.)
<TR><TD>
              EXEMODE         
          <TD>*<TD>File permissions on Main targets.
<TR><TD>
              MODE            
          <TD><TD>Target-specific file permissions on Main targets
        (set from &#36;(EXEMODE))

<TR><TD>
              RANLIB          
          <TD><TD>Name of ranlib program, if any.
</TABLE>
</CENTER>

<P>
    Variables above marked with "*" are used by the build rules. Their 
    values at the time the rules are invoked are used to set target-specific 
    variables.
<P>
    All other variables listed above are globally defined, and are used in 
    actions that update build targets. This means that the global values of 
    those variables are used, unless target-specific values have been set. 
    (For instance, a target-specific MODE value is set by the Main rule.)
    The target-specific values always override global values.
<P>
    Note that there are several ways to specify link libraries for
    executables: 
    <UL>
        <LI>Use the LinkLibraries rule 
        to specify built libraries; i.e., libraries
        that are built by Library rules. This assures that
        these libraries are built first, and that Main targets are 
        rebuilt when the libraries are updated.
        <P>

        <LI>Use the LinkLibs rule or LINKLIBS variable to specify external
         libraries; e.g., system libraries or third-party libraries.
         The actual link command flag that specifies the libraries has to be used.
         <P>
     </UL>
     <P>
     For example:
<PRE>
    <I>#In Jamrules:</I>
        X11LINKLIBS ?= -lXext -lX11 ;

    <I>#In Jamfile:</I>
        Library libxutil : xtop.c xbottom.c xutil.c ;
        
        Main xprog : xprog.c ;
        LinkLibraries xprog : libxutil ;

        LinkLibs xprog : &#36;(X11LINKLIBS) ;
        # Or: LINKLIBS on xprog&#36;(SUFEXE) = &#36;(X11LINKLIBS) ;
</PRE>
       This  example  uses the Jam syntax "variable on target" to
       set a target-specific variable.  In this way,  only  xprog
       will  be linked with this special &#36;(X11LINKLIBS),
       even if other executables were going to  be  built
       by  the  same Jamfile. Note that when you set a variable
       on a target, you have to specify the target identifer
       exactly, which in this case is the suffixed filename of
       the executable. Therefore you should always prefer to use
       the LinkLibs rule instead of setting the LINKLIBS variable
       directly.
       The actual link command line on Unix, for example, would
       look something like this:
<PRE>
              cc -o xprog xprog.o libxutil.a -lXext -lX11
</PRE>

<A NAME="jam_compiling"><H1>Compiling</H1></A>

       Compiling of source files occurs normally as  a  byproduct
       of  the Main or Library rules, which call the rules 
       described here. These rules may also be called explicitly
       if the Main and Library behavior doesn't satisfy your
       requirements.
<P>
<H4>
   Objects Rule

</H4>
       The Main and Library rules call the Objects rule on source files.
       Compiled object files built by
       the Objects rule are a dependency of the <I>obj</i>
       pseudotarget, so "jam obj" will build object files used in 
       Main and Library rules.
       <P>
       Target identifiers created by the Objects rule have grist
       set to &#36;(SOURCE_GRIST). So given this Jamfile:
       <PRE>
        SubDir TOP src lock ;
        Main locker : lock.c ;
       </PRE>
       the object file created is lock.o (or lock.obj) and
       its target identifier is &lt;src!lock&gt;lock.o 
       (or &lt;src!lock&gt;lock.obj).

       <P>

       You can also call  Objects  directly.  For example:
<PRE>
              Objects a.c b.c c.c ;
</PRE>
       This compiles a.c into a.o, b.c into b.o, etc. The object
       file suffix is supplied by the Objects rule.
<P>
<H4>
   Object Rule
</H4>
       Objects  gets  its work done by calling the Object rule on
       each of the source files.
       You could use the Object rule directly.
       For example, on Unix, you could use:
<PRE>
              Object foo.o : foo.c ;

</PRE>
    However, the Object rule does not provide suffixes, and
    it does not provide the grist needed to construct target
    identifiers if you are using the SubDir* rules.
    A portable and robust Jamfile would need to invoke Object thus:
    <PRE>
          Object &lt;src!util&gt;foo&#36;(SUFOBJ) : &lt;src!util&gt;foo.c ;
    </PRE>
    which is inelegant and clearly shows why using Objects
    is better than using Object.
    <P>
    If there's any advantage to the Object rule, it's
       that it doesn't require that the object name bear
       any relationship to the source.  It is  thus  possible  to
       compile  the  same file into different objects.  For example:

<PRE>

              Object a.o : foo.c ;
              Object b.o : foo.c ;
              Object c.o : foo.c ;
</PRE>
       This compiles foo.c (three times) into a.o, b.o, and  c.o.
       Later examples show how this is useful.
<P>
       The Object rule looks at the suffix of the source file and
       calls the appropriate rules to do  the  actual  preprocessing
       (if any) and compiling needed to produce the output object file.
       The Object rule is
       capable of the generating of an object file from  any
       type of source.  For example:
<PRE>
              Object grammar&#36;(SUFOBJ) : grammar.y ;
              Object scanner&#36;(SUFOBJ) : scanner.l ;
              Object fastf&#36;(SUFOBJ) : fastf.f ;
              Object util&#36;(SUFOBJ) : util.c ;
</PRE>
    An even more elegant way to get the same result is to let the
    Objects rule call Object:
    <PRE>
              Objects grammar.y scanner.l fastf.f util.c ;
    </PRE>

    <P>
       In  addition to calling the compile rules, Object sets up
       a bunch of variables specific to  the  source  and  target
       files.  (See Variables Used in Compiling, below.)
<P>
<H4>
   Cc, C++, Yacc, Lex, Fortran, As, etc. Rules
</H4>
<P>
       The Object rule calls compile rules specific to the suffix of
       the source file.  (You can see which suffixes are supported
       by looking at the Object rule definition in Jambase.)
       Because  the  extra  work  done  by  the
       Object rule, it is not always useful to call the compile
       rules directly.  But the adventurous  user  might  attempt
       it.  For example:
<PRE>
              Yacc grammar.c : grammar.y ;
              Lex scan.c : scan.l ;
              Cc prog.o : prog.c ;
</PRE>
       These examples individually run yacc(1), lex(1), and the C
       compiler on their sources.

<P>
<H4>
   UserObject Rule
</H4>
       Any files with suffixes not understood by the Object  rule
       are passed to the UserObject rule.  The default definition
       of UserObject simply emits a warning that  the  suffix  is
       not  understood.   This  Jambase rule definition is intended to be
       overridden in Jamrules with one that recognizes the project-specific
       source file suffixes. For  example:

<PRE>
    #In Jamrules:

              rule UserObject
              {
                  switch &#36;(&gt;)
                  {
                  case *.rc   : ResourceCompiler &#36;(&lt;) : &#36;(&gt;) ;
                  case *      : ECHO "unknown suffix on" &#36;(&gt;) ;
                  }
              }

              rule ResourceCompiler
              {
                  DEPENDS &#36;(&lt;) : &#36;(&gt;) ;
          Clean clean : &#36;(<) ;
              }

              actions ResourceCompiler
              {
                  rc /fo &#36;(&lt;) &#36;(RCFLAGS) &#36;(&gt;)
              }


    #In Jamfile:

              Library liblock : lockmgr.c ;
          if &#36;(NT) { Library liblock : lock.rc ; }

</PRE>
<P>
    In this example, the UserObject definition in Jamrules
    allows *.rc files to be handle as regular Main and Library
    sources. The lock.rc file is compiled into lock.obj
    by the "rc" command, and lock.obj is archived into a library
    with other compiled objects.
<H4>
   LibraryFromObjects Rule
</H4>
       Sometimes the Library rule's straightforward compiling  of
       source  into  object modules to be archived isn't flexible
       enough.  The LibraryFromObjects rule  does  the  archiving
       (and  deleting)  job of the Library rule, but not the compiling.  
       The user can make use of the  Objects  or  Object
       rule for that.  For example:
<PRE>
              LibraryFromObjects libfoo.a : max.o min.o ;
              Object max.o : maxmin.c ;
              Object min.o : maxmin.c ;
              ObjectCcFlags max.o : -DUSEMAX ;
              ObjectCcFlags min.o : -DUSEMIN ;
</PRE>
       This  Unix-specific example compiles  the  same  source  file into 
       two different
       objects, with different compile flags, and archives  them.
       (The ObjectCcFlags rule is described shortly.)
       Unfortunately, the portable and robust implementation of the
       above example is not as pleasant to read:
       <PRE>

          SubDir TOP foo bar ;
              LibraryFromObjects libfoo&#36;(SUFLIB) : &lt;foo!bar&gt;max&#36;(SUFOBJ)
                                       &lt;foo!bar&gt;min&#36;(SUFOBJ) ;
              Object &lt;foo!bar&gt;min&#36;(SUFOBJ) : &lt;foo!bar&gt;maxmin.c ;
              Object &lt;foo!bar&gt;max&#36;(SUFOBJ) : &lt;foo!bar&gt;maxmin.c ;
          ObjectCcFlags &lt;foo!bar&gt;min&#36;(SUFOBJ) : -DUSEMIN ;
          ObjectCcFlags &lt;foo!bar&gt;max&#36;(SUFOBJ) : -DUSEMAX ;
       </PRE>

       Note that, among other things, you must supply the library
       file suffix when using the LibraryFromObjects rule.
<P>
<H4>
   MainFromObjects Rule
</H4>
       Similar  to  LibraryFromObjects,  MainFromObjects does the
       linking part of the Main rule, but not the compiling.
       MainFromObjects  can be used when  there  are no
       objects at all,  and  everything  is  to  be  loaded  from
       libraries.  For example:
<PRE>
              MainFromObjects testprog ;
              LinkLibraries testprog : libprog ;
              Library libprog : main.c util.c ;
</PRE>
       On Unix, say, this generates a link command that looks like:
<PRE>
              cc -o testprog libprog.a

</PRE>
       Linking  purely  from  libraries is something that doesn't
       work everywhere: it depends on  the  symbol  "main"  being
       undefined when the linker encounters the library that contains 
       the definition of "main".
<P>
<H4>
   Variables Used in Compiling
</H4>
       The following variables control the  compiling  of  source
       files:
<P>
<CENTER>
<TABLE>
<TR><TD VALIGN=TOP>
              C++              
          <TD><TD>The C++ compiler command

<TR><TD VALIGN=TOP>
              CC               
          <TD><TD>The C compiler command
<TR><TD VALIGN=TOP>
              C++FLAGS       
          <BR>
              CCFLAGS        
          <TD VALIGN=TOP><TD VALIGN=TOP>Compile flags, used to
         create or update compiled objects
<TR><TD>
              SUBDIRC++FLAGS 
          <BR>
              SUBDIRCCFLAGS  
          <TD VALIGN=TOP><TD VALIGN=TOP>Additonal compile flags
        for source files in this directory.

<TR><TD VALIGN=TOP>
              OPTIM            
          <TD><TD>Compiler optimization flag. The Cc and C++ 
        actions use this as well as C++FLAGS or CCFLAGS.
<TR><TD VALIGN=TOP>
              HDRS           
          <TD VALIGN=TOP><TD>Non-standard header directories; i.e.,
        the directories the compiler will not look in 
        by default and which therefore must be supplied
        to the compile command. These directories are
        also used by <b>jam</b> to scan for include files.
<TR><TD VALIGN=TOP>
              STDHDRS        
          <TD VALIGN=TOP><TD>Standard header directories, i.e., the
        directories the compiler searches automatically.
        These are not passed to the compiler, but they
        are used by <b>jam</b> to scan for include files.

<TR><TD>
              SUBDIRHDRS     
          <TD><TD>Additional paths to add to HDRS for source files
        in this directory.
<TR><TD>
              LEX              
          <TD><TD>The lex(1) command 
<TR><TD>
              YACC             
          <TD><TD>The yacc(1) command 
</TABLE>
</CENTER>
<P>
       The  Cc rule sets a target-specific &#36;(CCFLAGS) to the current
       value of &#36;(CCFLAGS) and &#36;(SUBDIRCCFLAGS).   Similarly
       for  the C++ rule.  The Object rule sets a target-specific
       &#36;(HDRS) to  the  current  value  of  &#36;(HDRS)  and  &#36;(SUBDDIRHDRS).


<P>
       &#36;(CC),  &#36;(C++),  &#36;(CCFLAGS),  &#36;(C++FLAGS),  &#36;(OPTIM),  and
       &#36;(HDRS) all affect the  compiling  of  C  and  C++  files.
       &#36;(OPTIM)  is  separate  from &#36;(CCFLAGS) and &#36;(C++FLAGS) so
       they can be set independently.
<P>
       &#36;(HDRS) lists the directories to search for header  files,
       and  it  is used in two ways: first, it is passed to the C
       compiler (with the flag -I prepended); second, it is  used
       by  HdrRule  to  locate  the header files whose names were
       found when scanning source files.   &#36;(STDHDRS)  lists  the
       header  directories  that  the  C  compiler  already knows
       about.  It does not need passing to the C compiler, but is
       used by HdrRule.
<P>
       Note that these variables, if set as target-specific variables, 
       must be set on the target,  not  the  source  file.
       The target file in this case is the object file to be generated.  
       For example:
<PRE>
              Library libximage : xtiff.c xjpeg.c xgif.c ;

              HDRS on xjpeg&#36;(SUFOBJ) = /usr/local/src/jpeg ;
              CCFLAGS on xtiff&#36;(SUFOBJ) = -DHAVE_TIFF ;
</PRE>
       This can be done more easily with the rules that follow.
<P>
<H4>

   ObjectCcFlags, ObjectC++Flags, ObjectHdrs Rules
</H4>
       &#36;(CCFLAGS), &#36;(C++FLAGS) and  &#36;(HDRS)  can  be  set on object file
       targets
       directly, but  there are rules that allow these variables
       to be set by referring to the original source  file  name,
       rather  than  to  the  derived object file name.  ObjectCcFlags 
       adds object-specific flags to the &#36;(CCFLAGS)  variable,
       ObjectC++Flags  adds  object-specific  flags to the
       &#36;(C++FLAGS) variable, and ObjectHdrs  add  object-specific
       directories to the &#36;(HDRS) variable.  For example:
<PRE>
    #In Jamrules:
        if &#36;(NT) { CCFLAGS_X = /DXVERSION ;
               HDRS_X = \\\\SPARKY\\X11\\INCLUDE\\X11 ;
                 }

    #In Jamfile:
              Main xviewer : viewer.c ;
              ObjectCcFlags viewer.c : &#36;(CCFLAGS_X) ;
              ObjectHdrs viewer.c : &#36;(HDRS_X) ;
</PRE>
    The ObjectCcFlags and ObjectHdrs rules take .c files
    as targets, but actually set &#36;(CCFLAGS) and &#36;(HDRS) values
    on the .obj (or .o) files. As a result, the action
    that updates the target .obj file uses the target-specific
    values of &#36;(CCFLAGS) and &#36;(HDRS).
<P>
<H4>
   SubDirCcFlags, SubDirC++Flags, SubDirLinkFlags, SubDirHdrs, SubDirObjects Rules
</H4>
       SubDirCcFlags, SubDirC++Flags and SubDirHdrs set the  values
       of  &#36;(SUBDIRCCFLAGS),  &#36;(SUBDIRC++FLAGS), &#36;(SUBDIRLINKFLAGS) and &#36;(SUBDIRHDRS)
       which are used by the Cc, C++, Link, and Object rules  when  setting
       the  target-specific values  for &#36;(CCFLAGS), &#36;(C++FLAGS), &#36;(LINKFLAGS) and &#36;(HDRS).
       The SubDir rule clears these variables out, and thus they provide
       directory-specific  values of &#36;(CCFLAGS), &#36;(C++FLAGS) and
       &#36;(HDRS). The SubDirObjects rule sets the default
       location for all object files generated by the Object rule in a
       specific directory.

       For example:

<PRE>
    #In Jamrules:
          GZHDRS = &#36;(TOP)/src/gz/include ;
          GZFLAG = -DGZ ;
          OBJS = &#36;(TOP)/objs

    #In Jamfile:
          SubDir TOP src gz utils ;

          SubDirHdrs &#36;(GZHDRS) ;
          SubDirCcFlags &#36;(GZFLAG) ;
          SubDirObjects &#36;(OBJS) ;

          Library libgz : gizmo.c ;
          Main gizmo : main.c ;
          LinkLibraries gizmo : libgz ;
</PRE>
    All .c files in this directory will be compiled with
    &#36;(GZFLAG) as well as the default &#36;(CCFLAG), and the include
    paths used on the compile command will be &#36;(GZHDRS) as well
    as the default &#36;(HDRS). All objects will be generated in
    &#36;(TOP)/objs.

<A NAME="jam_headers"><H1>Header File Processing</H1></A>

       One of the functions of the Object rule is set up 
       scanning of source
       files  for (C style) header file inclusions.  To do so, it
       sets the special variables &#36;(HDRSCAN)  and  &#36;(HDRRULE)
       as  target-specific  variables  on  the source file.  The
       presence of these variables triggers a  special  mechanism
       in  <B>jam</B> for scanning a file for header file inclusions and
       invoking a  rule  with  the  results  of  the  scan.   The
       &#36;(HDRSCAN)  variable  is  set  to an egrep(1) pattern that
       matches "#include" statements in C source files,  and  the
       &#36;(HDRRULE)  variable  is  set to the name of the rule that
       gets invoked as such:
<PRE>
              &#36;(HDRRULE) source-file : included-files ;

</PRE>
       This rule is supposed to set up the  dependencies  between
       the  source  file and the included files.  The Object rule
       uses HdrRule  to  do  the  job.   HdrRule  itself  expects
       another  variable,  &#36;(HDRSEARCH), to be set to the list of
       directories where the included files can be found.  Object
       does  this  as  well,  setting &#36;(HDRSEARCH) to &#36;(HDRS) and
       &#36;(STDHDRS).
<P>
       The header file scanning occurs during the "file  binding"
       phase   of  <b>jam</b>,  which  means  that  the  target-specific
       variables (for the source file) are in effect.  To accomodate 
       nested includes, one of the HdrRule's jobs is to pass
       the target-specific values of &#36;(HDRRULE), &#36;(HDRSCAN),  and
       &#36;(HDRSEARCH) onto the included files, so that they will be
       scanned as well.
<P>
<H4>
   HdrRule Rule
</H4>
    Normally, HdrRule is not invoked directly; the Object rule
    (called by Main and Library) invokes it.
    <P>
    If there are special dependencies that need to be set,
    and which are not set by HdrRule itself, you can define
    another rule and let it invoke HdrRule.  For example:


<PRE>
    #In Jamrules:
              rule BuiltHeaders
              {
                      DEPENDS &#36;(&gt;) : mkhdr&#36;(SUFEXE) ;
                      HdrRule &#36;(&lt;) : &#36;(&gt;) ;
              }

    #In Jamfile:
              Main mkhdr : mkhdr.c ;
              Main ugly : ugly.c ;

              HDRRULE on ugly.c = BuiltHeaders ;

</PRE>
       This example just says that the files included by "ugly.c"
       are  generated  by the program "mkhdr", which can be built
       from "mkhdr.c".  During the binding phase, <b>jam</b> will
       scan ugly.c, and if it finds an include file, ughdr.h,
       for example, it will automatically invoke the rule:
       <PRE>
              BuiltHeaders ugly.c : ughdr.h ;
       </PRE>
       By calling HdrRule at the end  of  BuiltHeaders,  
       all  the gadgetry of HdrRule takes effect and it
       doesn't need to be duplicated.

<P>
<H4>
   Variables Used for Header Scanning
</H4>
<CENTER>
<TABLE>
<TR><TD VALIGN=TOP>
              HDRPATTERN    
          <TD><TD>Default scan pattern for "include" lines.
<TR><TD VALIGN=TOP>
              HDRSCAN         
          <TD><TD>Scan pattern to use. 
        This is a special variable: during binding, if
        both HDRSCAN and HDRRULE are set, scanning is activated
        on the target being bound.
        The HdrRule and Object rules sets this
        to &#36;(HDRPATTERN) on their source targets.
<TR><TD VALIGN=TOP>
              HDRRULE         
          <TD><TD>Name of rule to invoked on files found in header
        scan. The HdrRule and Object rules set this to "HdrRule"
        on their source targets. This is also a special variable;
        it's the only <b>jam</b> variable that can hold the
        name of a rule to be invoked.

<TR><TD VALIGN=TOP>
              HDRSEARCH       
          <TD><TD>Search paths for files found during header scanning.
        This is set from &#36;(HDRS) and &#36;(STDHDRS), which are
        described in the Compiling section.
        <b>jam</b> will search &#36;(HDRSEARCH) directories for
        the files found by header scans. 
</TABLE>
</CENTER>
<P>
       The  Object rule sets HDRRULE and HDRSCAN specifically for
       the source files to be scanned, rather than globally.   If
       they  were  set  globally,  jam  would attempt to scan all
       files, even library archives and executables,  for  header
       file  inclusions.   That  would  be  slow and probably not
       yield desirable results.
<P>

<A NAME="jam_files"><H1>Copying Files</H1></A>

<H4>
   File Rule
</H4>
       The File rule copies one file to another.  The target name
       needn't  be the same as the source name.  For
       example:
<PRE>
    switch &#36;(OS)
    {
           case NT*  : File config.h : confignt.h ;
       case *    : File config.h : configunix.h ;
    }
    LOCATE on config.h = &#36;(LOCATE_SOURCE) ;
</PRE>
    This creates a config.h file from either confignt.h or
    configunix.h, depending on the current build platform.
<P>
    The File rule does not
    use the LOCATE_SOURCE variable set by the
    SubDir rule (although it does use SEARCH_SOURCE), which
    means you have to set the copied file's output directory
    yourself. That's done by setting the special
    LOCATE variable on the target, as shown above,
    or with the MakeLocate rule described below.
<H4>
   Bulk Rule

</H4>
       The Bulk rule is a shorthand for many invocations  of  the
       File  rule when all files are going to the same directory.
       For example:
<PRE>
    #In Jamrules:
              DISTRIB_GROB = d:\\distrib\\grob ;

    #In Jamfile:
              Bulk &#36;(DISTRIB_GROB) : grobvals.txt grobvars.txt ;
</PRE>
    This causes gobvals.txt and grobvars.txt to be copied
    into the &#36;(DISTRIB_GROB) directory.
<H4>
   HardLink Rule
</H4>
       The Unix-only HardLink rule makes a hard link (using ln(1)) from the
       source  to  the  target,  if there isn't one already.  For
       example:
<PRE>
              HardLink config.h : configunix.h ;

</PRE>
<H4>
   Shell Rule
</H4>
       The Shell rule is like the File rule, except that on Unix it makes
       sure  the first line of the target is "#!/bin/sh" and sets
       the permission to make the file executable.  For example:
<PRE>
              Shell /usr/local/bin/add : add.sh ;
</PRE>
<P>
    You can also use &#36;(SHELLHEADER) to dictate
    what the first line of the copied file will be.
       For
       example:
<PRE>
              Shell /usr/local/bin/add : add.awk ;
              SHELLHEADER on /usr/local/bin/add = "#!/bin/awk -f" ;

</PRE>
       This installs an awk(1) script.
<P>
<H4>
   Variables Used When Copying Files
</H4>
<CENTER>
<TABLE>
<TR><TD VALIGN=TOP>
              FILEMODE      
          <TD><TD>Default file permissions for copied files
<TR><TD VALIGN=TOP>
              SHELLMODE     
          <TD><TD>Default file permissions for Shell rule targets

<TR><TD VALIGN=TOP>
              MODE            
          <TD><TD>File permissions set on files copied by
        File, Bulk, and Shell rules. 
            File and Shell sets a target-specific MODE to the  current
            value  of  &#36;(FILEMODE) or &#36;(SHELLMODE), respectively.
<TR><TD VALIGN=TOP>
              SHELLHEADER     
          <TD><TD>String to write in first line of Shell targets 
          (default is #!/bin/sh).

</TABLE>
</CENTER>
<P>

<A NAME="jam_install"><H1>Installing Files</H1></A>

<H4> MakeInstall Rule </H4>
<P>
    The MakeInstall rule installs a target at a given location. It works for
    all targets defined by the Main, Library and SharedLibrary rules.

<PRE>
    Main myprog : main.c ;
    MakeInstall myprog :  ;
</PRE>

    This installs the program "myprog" to the path given by the variable
    MY_INSTALL_BINDIR. This rule calls one or more of the other Install*
    rules as appropriate.
<P>

<H4> Install Rules </H4>

Jambase provides a set of Install* rules to copy files
into an destination directory and set permissions on them.
On Unix, the install(1) program is used.
If the destination directory does not exist, <b>jam</b>

creates it first.
<P>
All files copied with the Install* rules are dependencies
of the <i>install</i> pseudotarget, which means that the
command "jam install" will cause the installed copies to
be updated. Also, "jam uninstall" will cause the installed
copies to be removed.
<P>
The Install* rules are:
<CENTER>
<TABLE>
<TR><TD VALIGN=TOP><B>InstallBin</B>
    <TD VALIGN=TOP>Copies file and sets its permission to &#36;(EXEMODE).
           You must specify the suffixed executable name. E.g.:
    <PRE>InstallBin &#36;(BINDIR) : thing&#36;(SUFEXE) ;
           </PRE>

<TR><TD VALIGN=TOP><B>InstallFile</B>
    <TD VALIGN=TOP>Copies file and sets its permission to &#36;(FILEMODE). E.g.:
    <PRE>InstallFile &#36;(DESTDIR) : readme.txt ;
           </PRE>

<TR><TD VALIGN=TOP><B>InstallLib</B>
    <TD VALIGN=TOP>Copies file and sets its permission to &#36;(FILEMODE).
           You must specify the suffixed library name. E.g.:
    <PRE>InstallLib &#36;(LIBDIR) : libzoo&#36;(SUFLIB) ;
           </PRE>

<TR><TD VALIGN=TOP><B>InstallMan</B>
    <TD VALIGN=TOP>Copies file into the man<i>n</i>

           subdirectory of the target directory
           and sets its permission to &#36;(FILEMODE). E.g.,
           this copies foo.5 into the &#36;(DESTDIR)/man5 directory:
    <PRE>InstallMan &#36;(DESTDIR) : foo.5 ;
           </PRE>

<TR><TD VALIGN=TOP><B>InstallShell</B>
    <TD VALIGN=TOP>Copies file and sets its permission to &#36;(SHELLMODE). E.g.:
    <PRE>InstallShell &#36;(DESTDIR) : startup ;
           </PRE>

</TABLE>
</CENTER>
<P>
<P>
<H4>

   Variables
</H4>
       The following variables control the installation rules:
<P>
<CENTER>
<TABLE>
<TR><TD>
              INSTALL        
          <TD><TD>The install program (Unix only)
<TR><TD>
              FILEMODE     
          <TD><TD>Default file permissions on readable files. 
<TR><TD>

              EXEMODE      
          <TD><TD>Default file permission executable files.
<TR><TD>
              SHELLMODE    
          <TD><TD>Default file permission on shell script files.
<TR><TD>
              MODE           
          <TD><TD>Target-specific file permissions
</TABLE>
</CENTER>
<P>
<P>
       The  Install  rules set a target-specific MODE to the current 
       value of &#36;(FILEMODE),  &#36;(EXEMODE),  or  &#36;(SHELLMODE),
       depending on which Install rule was invoked.

<P>
       The  directory variables are just defined for convenience:
       they must be passed  as  the  target  to  the  appropriate
       Install  rule.   The &#36;(INSTALL) and mode variables must be
       set (globally) before calling the Install rules  in  order
       to take effect.
<P>

<A NAME="jam_misc"><H1>Miscellaneous Rules</H1></A>

<H4>
Clean Rule
</H4>
<P>
The Clean rule defines files to be removed when you run "jam clean".
Any site-specific build rules defined in your Jamrules should invoke
Clean so that outputs can be removed. E.g.,
<PRE>
    rule ResourceCompiler
    {
       DEPENDS &#36;(<) : &#36;(>) ;
       Clean clean : &#36;(<) ;
    }

</PRE>
<P>
<P>
Most Jambase rules invoke the Clean rule on their built targets,
so "jam clean" will remove all compiled objects, libraries,
executables, etc.
<P>
<H4>
MakeLocate Rule
</H4>
      MakeLocate is a single convenient rule that creates a directory,
      sets LOCATE on a target to that directory, and makes the directory
      a dependency of the target. It is used by many Jambase rules,
      and can be invoked directly, e.g.:
      <PRE>
        GenFile data.tbl : hxtract data.h ;
        MakeLocate data.tbl : &#36;(TABLEDIR) ;
      </PRE>
      In this example, the File rule creates data.tbl from data.h.
      The MakeLocate causes data.tbl to be written into the &#36;(TABLEDIR)
      directory; and if the directory doesn't exist, it is created first.
      <P>
      The MakeLocate rule can be used to build targets introduced by
      Main, Library or SharedLibrary at a specific location.
      <PRE>
        Main myprog : main.c ;
        MakeLocate myprog : &#36;(OUTPUT) ;
      </PRE>
      In the example above the program 'myprog' is built at the location
      specified by the variable OUTPUT.
      <P>
      The MakeLocate rule invokes another Jambase rule, MkDir,
      to (recursively) create
      directories. MkDir uses the &#36;(MKDIR) variable to determine the
      platform-specific command that creates directories.
<P>
<H4>
RmTemps Rule
</H4>
    Some intermediate files are meant to be temporary. 
    The RmTemps rule can be used to cause 
    <b>jam</b> to delete them after they are used. 
    <P>
    RmTemps must be:
    <UL>
    <LI>

    the last rule 
    invoked on the permanent file that uses
    the temporary file(s) 
    <LI>
    invoked with the permanent file as the output
    target and the temporary file(s) as the input target
    <LI>
    invoked with the exact target identifiers of
    the permanent file and the temporary file(s)
    </UL>
    For
    example: 
    <PRE>
        SubDir TOP src big ;
        GenFile big.y : joinfiles part1.y part2.y part3.y ;
        Main bigworld : main.c big.y ;
        RmTemps bigworld&#36;(SUFEXE) : &lt;src!big&gt;big.y ;
    </PRE>

    This causes big.y to be deleted after it has been used to create
    the bigworld executable. 
    The exact target identifier of big.y is  &lt;src!big&gt;big.y
    (the GenFile and Main rules tack on the grist automatically);
    the exact target identifier of the bigworld executable
    is bigworld&#36;(SUFEXE).
<P>

 </div></div><!-- contents -->

<div class="clear">&nbsp;</div>
<div id="footer">
	<div style="float:left;">Copyright &copy; 2003-2014 The Pt Development Team</div>
</div>
</div>
</body>
</html>
